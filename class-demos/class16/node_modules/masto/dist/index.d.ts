import { CustomError } from 'ts-custom-error';

declare class MastoUnexpectedError extends CustomError {
}

declare class MastoDeserializeError extends CustomError {
    readonly contentType: string;
    readonly data: unknown;
    constructor(message: string, contentType: string, data: unknown, options?: ErrorOptions);
}

type MastoErrorType = "ERR_BLOCKED" | "ERR_UNREACHABLE" | "ERR_TAKEN" | "ERR_RESERVED" | "ERR_ACCEPTED" | "ERR_BLANK" | "ERR_INVALID" | "ERR_TOO_LONG" | "ERR_TOO_SHORT" | "ERR_INCLUSION";
interface MastoHttpErrorDetail {
    readonly error: MastoErrorType;
    readonly description: string;
}
type MastoHttpErrorDetails = Record<string, readonly MastoHttpErrorDetail[]>;
interface MastoHttpErrorProps {
    readonly statusCode: number;
    readonly message: string;
    readonly description?: string;
    readonly details?: MastoHttpErrorDetails;
    readonly additionalProperties?: Record<string, unknown>;
}
declare class MastoHttpError extends CustomError {
    readonly statusCode: number;
    readonly description?: string;
    readonly details?: MastoHttpErrorDetails;
    readonly additionalProperties?: Record<string, unknown>;
    constructor(props: MastoHttpErrorProps, errorOptions?: ErrorOptions);
}

declare class MastoInvalidArgumentError extends CustomError {
}

declare class MastoTimeoutError extends CustomError {
}

declare class MastoWebSocketError extends CustomError {
    constructor(message: string, options?: ErrorOptions);
}

type Encoding = "none" | "json" | "multipart-form" | "querystring";

interface HttpMetaParams<T extends Encoding = "none"> {
    readonly encoding?: T;
    readonly requestInit?: Omit<RequestInit, "body" | "method">;
}

type LogType = "debug" | "info" | "warn" | "error";

/**
 * Represents a custom emoji.
 * @see https://docs.joinmastodon.org/entities/CustomEmoji/
 */
interface CustomEmoji {
    /** The name of the custom emoji. */
    shortcode: string;
    /** A link to the custom emoji. */
    url: string;
    /** A link to a static copy of the custom emoji. */
    staticUrl: string;
    /** Whether this Emoji should be visible in the picker or unlisted. */
    visibleInPicker: boolean;
    /** Used for sorting custom emoji in the picker. */
    category?: string | null;
}

/**
 * Represents a custom user role that grants permissions.
 * @see https://docs.joinmastodon.org/entities/Role/
 */
interface Role {
    /** The ID of the Role in the database. */
    id: number;
    /** The name of the role. */
    name: string;
    /** The hex code assigned to this role. If no hex code is assigned, the string will be empty */
    color: string;
    /** An index for the role’s position. The higher the position, the more priority the role has over other roles. */
    position: number;
    /** A bitmask that represents the sum of all permissions granted to the role. */
    permissions: number;
    /** Whether the role is publicly visible as a badge on user profiles. */
    highlighted: boolean;
    /** The date that the role was created. */
    createdAt: string;
    /** The date that the role was updated. */
    updatedAt: string;
}

/**
 * Represents an application that interfaces with the REST API to access accounts or post statuses.
 * @see https://docs.joinmastodon.org/entities/application/
 */
interface Application {
    /** The name of your application. */
    name: string;
    /** The website associated with your application. */
    website?: string | null;
    /** Used for Push Streaming API. Returned with POST /api/v1/apps. Equivalent to PushSubscription#server_key */
    vapidKey?: string | null;
}
interface Client$3 extends Application {
    /** Client ID key, to be used for obtaining OAuth tokens */
    clientId?: string | null;
    /** Client secret key, to be used for obtaining OAuth tokens */
    clientSecret?: string | null;
}

/**
 * Represents a keyword that, if matched, should cause the filter action to be taken.
 * @see https://docs.joinmastodon.org/entities/FilterKeyword/
 */
interface FilterKeyword {
    /** The ID of the FilterKeyword in the database. */
    id: string;
    /** The phrase to be matched against. */
    keyword: string;
    /** Should the filter consider word boundaries? See [implementation guidelines](https://docs.joinmastodon.org/api/guidelines/#filters) for filters. */
    wholeWord: boolean;
}

/**
 * Represents a status ID that, if matched, should cause the filter action to be taken.
 * @see https://docs.joinmastodon.org/entities/FilterStatus/
 */
interface FilterStatus {
    /** The ID of the FilterStatus in the database. */
    id: string;
    /** The ID of the filtered Status in the database. */
    statusId: string;
}

type FilterContext$1 = "home" | "notifications" | "public" | "thread" | "account";
type FilterAction = "warn" | "hide";
/**
 * Represents a user-defined filter for determining which statuses should not be shown to the user.
 * @see https://docs.joinmastodon.org/entities/filter/
 */
interface Filter$1 {
    /** The ID of the filter in the database. */
    id: string;
    /** A title given by the user to name the filter. */
    title: string;
    /** The contexts in which the filter should be applied. */
    context: FilterContext$1[];
    /** When the filter should no longer be applied */
    expiresAt?: string | null;
    /**
     * The action to be taken when a status matches this filter.
     *
     * `warn` = show a warning that identifies the matching filter by title, and allow the user to expand the filtered status. This is the default (and unknown values should be treated as equivalent to warn).
     *
     * `hide` = do not show this status if it is received
     */
    filterAction: FilterAction;
    /** The keywords grouped under this filter. */
    keywords: FilterKeyword[];
    /** The statuses grouped under this filter. */
    statuses: FilterStatus[];
}

/**
 * Represents a filter whose keywords matched a given status.
 * @see https://docs.joinmastodon.org/entities/FilterResult/
 */
interface FilterResult {
    /** The filter that was matched. */
    filter: Filter$1;
    /** The keyword within the filter that was matched. */
    keywordMatches: string[] | null;
    /** The status ID within the filter that was matched. */
    statusMatches: string[] | null;
}

type MediaAttachmentType = "image" | "video" | "gifv" | "audio" | "unknown";
interface MediaAttachmentMetaImage {
    width: number;
    height: number;
    size: string;
    aspect: number;
}
interface MediaAttachmentMetaVideo {
    width: number;
    height: number;
    frameRate: string;
    duration: number;
    bitrate: number;
    aspect: number;
}
interface MediaAttachmentMetaFocus {
    x: number;
    y: number;
}
interface MediaAttachmentMetaColors {
    background: string;
    foreground: string;
    accent: string;
}
interface MediaAttachmentMeta {
    small?: MediaAttachmentMetaImage | MediaAttachmentMetaVideo | null;
    original?: MediaAttachmentMetaImage | MediaAttachmentMetaVideo | null;
    focus?: MediaAttachmentMetaFocus | null;
    colors?: MediaAttachmentMetaColors | null;
}
/**
 * Represents a file or media MediaAttachment that can be added to a status.
 * @see https://docs.joinmastodon.org/entities/MediaAttachment/
 */
interface MediaAttachment {
    /** The ID of the MediaAttachment in the database. */
    id: string;
    /** The type of the MediaAttachment. */
    type: MediaAttachmentType;
    /** The location of the original full-size MediaAttachment. */
    url?: string | null;
    /** The location of a scaled-down preview of the MediaAttachment. */
    previewUrl: string;
    /** The location of the full-size original MediaAttachment on the remote website. */
    remoteUrl?: string | null;
    /** Remote version of previewUrl */
    previewRemoteUrl?: string | null;
    /** A shorter URL for the MediaAttachment. */
    textUrl?: string | null;
    /** Metadata returned by Paperclip. */
    meta?: MediaAttachmentMeta | null;
    /**
     * Alternate text that describes what is in the media MediaAttachment,
     * to be used for the visually impaired or when media MediaAttachments do not load.
     */
    description?: string | null;
    /**
     * A hash computed by the BlurHash algorithm,
     * for generating colorful preview thumbnails when media has not been downloaded yet.
     */
    blurhash?: string | null;
}

interface PollOption {
    /** The text value of the poll option. String. */
    title: string;
    /** The number of received votes for this option. Number, or null if results are not published yet. */
    votesCount?: number;
    /** Custom emoji to be used for rendering poll options. */
    emojis: CustomEmoji[];
}
/**
 * Represents a poll attached to a status.
 * @see https://docs.joinmastodon.org/entities/poll/
 */
interface Poll {
    /** The ID of the poll in the database. */
    id: string;
    /** When the poll ends. */
    expiresAt?: string | null;
    /** Is the poll currently expired? */
    expired: boolean;
    /** Does the poll allow multiple-choice answers? */
    multiple: boolean;
    /** How many votes have been received. */
    votesCount: number;
    /** How many unique accounts have voted on a multiple-choice poll. */
    votersCount?: number | null;
    /** When called with a user token, has the authorized user voted? */
    voted?: boolean;
    /**
     * When called with a user token, which options has the authorized user chosen?
     * Contains an array of index values for options.
     */
    ownVotes?: number[] | null;
    /** Possible answers for the poll. */
    options: PollOption[];
}

/**
 * Represents daily usage history of a hashtag.
 */
interface TagHistory$1 {
    /** UNIX timestamp on midnight of the given day. */
    day: string;
    /** the counted usage of the tag within that day. */
    uses: string;
    /** the total of accounts using the tag within that day. */
    accounts: string;
}
/**
 * Represents a hashtag used within the content of a status.
 * @see https://docs.joinmastodon.org/entities/tag/
 */
interface Tag$1 {
    /** The value of the hashtag after the # sign. */
    name: string;
    /** A link to the hashtag on the instance. */
    url: string;
    /** Usage statistics for given days. */
    history?: TagHistory$1[] | null;
    /** Whether the current token’s authorized user is following this tag. */
    following?: boolean | null;
}

type PreviewCardType = "link" | "photo" | "video" | "rich";
/**
 * Represents an author in a rich preview card.
 * @see https://docs.joinmastodon.org/entities/PreviewCardAuthor/
 */
interface PreviewCardAuthor {
    /** The original resource author’s name. Replaces the deprecated author_name attribute of the preview card. */
    name: string;
    /** A link to the author of the original resource. Replaces the deprecated author_url attribute of the preview card. */
    url: string;
    /** The fediverse account of the author. */
    account: Account$1 | null;
}
/**
 * Represents a rich preview card that is generated using OpenGraph tags from a URL.
 * @see https://docs.joinmastodon.org/entities/PreviewCard
 */
interface PreviewCard {
    /** Location of linked resource. */
    url: string;
    /** Title of linked resource. */
    title: string;
    /** Description of preview. */
    description: string;
    /** The type of the preview card. */
    type: PreviewCardType;
    /** Blurhash */
    blurhash: string;
    /** Fediverse account of the authors of the original resource. */
    authors: PreviewCardAuthor[];
    /**
     * The author of the original resource.
     * @deprecated Use `authors` instead
     */
    authorName?: string | null;
    /**
     * A link to the author of the original resource.
     * @deprecated Use `authors` instead
     */
    authorUrl?: string | null;
    /** The provider of the original resource. */
    providerName?: string | null;
    /** A link to the provider of the original resource. */
    providerUrl?: string | null;
    /** HTML to be used for generating the preview card. */
    html?: string | null;
    /** Width of preview, in pixels. */
    width?: number | null;
    /** Height of preview, in pixels. */
    height?: number | null;
    /** Preview thumbnail. */
    image?: string | null;
    /** Used for photo embeds, instead of custom `html`. */
    embedUrl: string;
    /** @see https://github.com/mastodon/mastodon/pull/27503 */
    language?: string;
}
interface TrendLink extends PreviewCard {
    history: TagHistory$1[];
}

/**
 * Represents a mention of a user within the content of a status.
 * @see https://docs.joinmastodon.org/entities/mention/
 */
interface StatusMention {
    /** The account id of the mentioned user. */
    id: string;
    /** The username of the mentioned user. */
    username: string;
    /** The location of the mentioned user's profile. */
    url: string;
    /**
     * The WebFinger acct: URI of the mentioned user.
     * Equivalent to username for local users, or `username@domain` for remote users.
     */
    acct: string;
}
type StatusVisibility = "public" | "unlisted" | "private" | "direct";
/**
 * Represents a status posted by an account.
 * @see https://docs.joinmastodon.org/entities/status/
 */
interface Status {
    /** ID of the status in the database. */
    id: string;
    /** URI of the status used for federation. */
    uri: string;
    /** The date when this status was created. */
    createdAt: string;
    /** Timestamp of when the status was last edited. */
    editedAt: string | null;
    /** The account that authored this status. */
    account: Account$1;
    /** HTML-encoded status content. */
    content: string;
    /** Visibility of this status. */
    visibility: StatusVisibility;
    /** Is this status marked as sensitive content? */
    sensitive: boolean;
    /** Subject or summary line, below which status content is collapsed until expanded. */
    spoilerText: string;
    /** Media that is attached to this status. */
    mediaAttachments: MediaAttachment[];
    /** The application used to post this status. */
    application: Application;
    /** Mentions of users within the status content. */
    mentions: StatusMention[];
    /** Hashtags used within the status content. */
    tags: Tag$1[];
    /** Custom emoji to be used when rendering status content. */
    emojis: CustomEmoji[];
    /** How many boosts this status has received. */
    reblogsCount: number;
    /** How many favourites this status has received. */
    favouritesCount: number;
    /** If the current token has an authorized user: The filter and keywords that matched this status. */
    filtered?: FilterResult[];
    /** How many replies this status has received. */
    repliesCount: number;
    /** A link to the status's HTML representation. */
    url?: string | null;
    /** ID of the status being replied. */
    inReplyToId?: string | null;
    /** ID of the account being replied to. */
    inReplyToAccountId?: string | null;
    /** The status being reblogged. */
    reblog?: Status | null;
    /** The poll attached to the status. */
    poll?: Poll | null;
    /** Preview card for links included within status content. */
    card?: PreviewCard | null;
    /** Primary language of this status. */
    language?: string | null;
    /**
     * Plain-text source of a status. Returned instead of `content` when status is deleted,
     * so the user may redraft from the source text without the client having
     * to reverse-engineer the original text from the HTML content.
     */
    text?: string | null;
    /** Have you favourited this status? */
    favourited?: boolean | null;
    /** Have you boosted this status? */
    reblogged?: boolean | null;
    /** Have you muted notifications for this status's conversation? */
    muted?: boolean | null;
    /** Have you bookmarked this status? */
    bookmarked?: boolean | null;
    /** Have you pinned this status? Only appears if the status is pin-able. */
    pinned?: boolean | null;
}

/**
 * Represents display or publishing preferences of user's own account.
 * Returned as an additional entity when verifying and updated credentials, as an attribute of Account.
 * @see https://docs.joinmastodon.org/entities/source/
 */
interface AccountSource {
    /** Profile bio. */
    note: string;
    /** Metadata about the account. */
    fields: AccountField[];
    /** The default post privacy to be used for new statuses. */
    privacy?: StatusVisibility | null;
    /** Whether new statuses should be marked sensitive by default. */
    sensitive?: boolean | null;
    /** The default posting language for new statuses. */
    language: string | null;
    /** The number of pending follow requests. */
    followRequestsCount?: number | null;
}
/**
 * Represents a profile field as a name-value pair with optional verification.
 */
interface AccountField {
    /** The key of a given field's key-value pair. */
    name: string;
    /** The value associated with the `name` key. */
    value: string;
    /** Timestamp of when the server verified a URL value for a rel="me” link. */
    verifiedAt?: string | null;
}
/**
 * Represents a user of Mastodon and their associated profile.
 * @see https://docs.joinmastodon.org/entities/account/
 */
interface Account$1 {
    /** The account id */
    id: string;
    /** The username of the account, not including domain */
    username: string;
    /** The WebFinger account URI. Equal to `username` for local users, or `username@domain` for remote users. */
    acct: string;
    /** The location of the user's profile page. */
    url: string;
    /** The profile's display name. */
    displayName: string;
    /** The profile's bio / description. */
    note: string;
    /** An image icon that is shown next to statuses and in the profile. */
    avatar: string;
    /** A static version of the `avatar`. Equal to avatar if its value is a static image; different if `avatar` is an animated GIF. */
    avatarStatic: string;
    /** An image banner that is shown above the profile and in profile cards. */
    header: string;
    /** A static version of the header. Equal to `header` if its value is a static image; different if `header` is an animated GIF. */
    headerStatic: string;
    /** Whether the account manually approves follow requests. */
    locked: boolean;
    /** Additional metadata attached to a profile as name-value pairs. */
    fields: AccountField[];
    /** Custom emoji entities to be used when rendering the profile. If none, an empty array will be returned. */
    emojis: CustomEmoji[];
    /** Boolean to indicate that the account performs automated actions */
    bot: boolean;
    /** Indicates that the account represents a Group actor. */
    group: boolean;
    /** Whether the account has opted into discovery features such as the profile directory. */
    discoverable?: boolean | null;
    /** Whether the local user has opted out of being indexed by search engines. */
    noindex?: boolean | null;
    /** Indicates that the profile is currently inactive and that its user has moved to a new account. */
    moved?: Account$1 | null;
    /** An extra entity returned when an account is suspended. **/
    suspended?: boolean | null;
    /** An extra attribute returned only when an account is silenced. If true, indicates that the account should be hidden behind a warning screen. */
    limited?: boolean | null;
    /** When the account was created. */
    createdAt: string;
    /** Time of the last status posted */
    lastStatusAt: string;
    /** How many statuses are attached to this account. */
    statusesCount: number;
    /** The reported followers of this profile. */
    followersCount: number;
    /** The reported follows of this profile. */
    followingCount: number;
    /** Roles that have been granted to this account. */
    roles: Pick<Role, "id" | "name" | "color">[];
    /** https://github.com/mastodon/mastodon/pull/23591 */
    memorial?: boolean | null;
}
/**
 * @see https://docs.joinmastodon.org/entities/Account/#CredentialAccount
 */
interface AccountCredentials extends Account$1 {
    /**
     * Note the extra `source` property, which is not visible on accounts other than your own.
     * Also note that plain-text is used within `source` and HTML is used for their
     * corresponding properties such as `note` and `fields`.
     */
    source: AccountSource;
    /** The role assigned to the currently authorized user. */
    role: Role;
}

/**
 * Represents an IP address associated with a user.
 * @see https://docs.joinmastodon.org/entities/Admin_Ip/
 */
interface Ip {
    /** The IP address. */
    ip: string;
    /** The timestamp of when the IP address was last used for this account. */
    usedAt: string;
}

/**
 * Admin-level information about a given account.
 * @see https://docs.joinmastodon.org/entities/admin-account/
 */
interface Account {
    /** The ID of the account in the database. */
    id: string;
    /** The username of the account. */
    username: string;
    /** The domain of the account. */
    domain?: string | null;
    /** When the account was first discovered. */
    createdAt: string;
    /** The email address associated with the account. */
    email: string;
    /** The IP address last used to login to this account. */
    ip?: string | null;
    /** All known IP addresses associated with this account. */
    ips: Ip[];
    /** The locale of the account. */
    locale: string;
    /** The reason given when requesting an invite (for instances that require manual approval of registrations) */
    inviteRequest?: string | null;
    /** The current role of the account. */
    role: Role;
    /** Whether the account has confirmed their email address. */
    confirmed: boolean;
    /** Whether the account is currently approved. */
    approved: boolean;
    /** Whether the account is currently disabled. */
    disabled: boolean;
    /** Whether the account is currently silenced. */
    silenced: boolean;
    /** Whether the account is currently suspended. */
    suspended: boolean;
    /** Boolean. Filter for accounts force-marked as sensitive? */
    sensitized: boolean;
    /** User-level information about the account. */
    account: Account$1;
    /** The ID of the application that created this account. */
    createdByApplicationId?: string | null;
    /** The ID of the account that invited this user */
    invitedByAccountId?: string | null;
}

interface CanonicalEmailBlock {
    /** The ID of email block in the database. */
    id: string;
    /** The hash to test against. */
    canonicalEmailHash: string;
}

type CohortFrequency = "day" | "month";
interface CohortData {
    /** The timestamp for the start of the bucket, at midnight. */
    date: string;
    /** The percentage rate of users who registered in the specified `period` and were active for the given `date` bucket. */
    rate: number;
    /** How many users registered in the specified `period` and were active for the given `date` bucket. */
    value: number;
}
/**
 * Represents a retention metric.
 */
interface Cohort {
    /** The timestamp for the start of the period, at midnight. */
    period: string;
    /** The size of the bucket for the returned data. */
    frequency: CohortFrequency;
    /** Retention data for users who registered during the given period. */
    data: CohortData[];
}

interface DimensionData {
    /** The unique keystring for this data item. */
    key: string;
    /** A human-readable key for this data item. */
    humanKey: string;
    /** The value for this data item. */
    value: string;
    /** The units associated with this data item’s value, if applicable. */
    unit?: string | null;
    /** A human-readable formatted value for this data item. */
    humanValue?: string | null;
}
type DimensionKey = "languages" | "sources" | "servers" | "space_usage" | "software_versions" | "tag_servers" | "tag_languages" | "instance_accounts" | "instance_languages";
/**
 * Represents qualitative data about the server.
 * @see https://docs.joinmastodon.org/entities/Admin_Dimension/
 */
interface Dimension {
    /** The unique keystring for the requested dimension. */
    key: DimensionKey;
    /** The data available for the requested dimension. */
    data: DimensionData[];
}

interface DomainAllow {
    /** The ID of the domain allow in the database. */
    id: string;
    /** The domain of the domain allow in the database. */
    domain: string;
    /** The create date of the domain allow in the database. */
    createdAt: string;
}

type DomainBlockSeverity$1 = "silence" | "suspend" | "noop";
interface DomainBlock$1 {
    /** The ID of the domain block in the database. */
    id: string;
    /** The domain of the domain block in the database. */
    domain: string;
    /** The create date of the domain block in the database. */
    createdAt: string;
    /** The date of the application that created this account. */
    severity: DomainBlockSeverity$1;
    /** The reject media of the domain. */
    rejectMedia: boolean;
    /** The reject report of the domain. */
    rejectReposts: boolean;
    /** The private comment of the domain. */
    privateComment?: string | null;
    /** The public comment of the domain. */
    publicComment?: string | null;
    /** The obfuscate of the domain block. */
    obfuscate: boolean;
    /** SHA256 of the domain. https://github.com/mastodon/mastodon/pull/29092 */
    digest: string;
}

interface EmailDomainBlockHistory {
    /** UNIX timestamp on midnight of the given day. */
    day: string;
    /** The counted accounts signup attempts using that email domain within that day. */
    accounts: string;
    /** The counted IP signup attempts of that email domain within that day. */
    uses: string;
}
interface EmailDomainBlock {
    /** The ID of the email domain block in the database. */
    id: string;
    /** The domain of the email domain block in the database. */
    domain: string;
    /** The create date of the email domain block in the database. */
    createdAt: string;
    /** The history of the email domain block in the database. */
    history: EmailDomainBlockHistory[];
}

type IpBlockSeverity = "sign_up_requires_approval" | "sign_up_block" | "no_access";
interface IpBlock {
    /** The ID of the domain allow in the database. */
    id: string;
    /** The IP address and prefix to block. */
    ip: string;
    /** The policy to apply to this IP range. */
    severity: IpBlockSeverity;
    /** The reason for this IP block. */
    comment: string;
    /** The create date of the ip block. */
    createdAt: string;
    /** The number of seconds in which this IP block will expire. */
    expiresAt: number | null;
}

interface MeasureData {
    /** Midnight on the requested day in the time period. */
    date: string;
    /** The numeric value for the requested measure. */
    value: string;
}
/** @see https://docs.joinmastodon.org/entities/Admin_Measure/#key */
type MeasureKey = "active_users" | "new_users" | "interactions" | "opened_reports" | "resolved_reports" | "tag_accounts" | "tag_uses" | "tag_servers" | "instance_accounts" | "instance_media_attachments" | "instance_reports" | "instance_statuses" | "instance_follows" | "instance_followers";
/**
 * Represents quantitative data about the server.
 * @see https://docs.joinmastodon.org/entities/Admin_Measure
 */
interface Measure {
    /** The unique keystring for the requested measure. */
    key: MeasureKey;
    /** The units associated with this data item’s value, if applicable. */
    unit?: string | null;
    /** The numeric total associated with the requested measure. */
    total: string;
    /** A human-readable formatted value for this data item. */
    humanValue?: string;
    /** The numeric total associated with the requested measure, in the previous period. Previous period is calculated by subtracting the start_at and end_at dates, then offsetting both start and end dates backwards by the length of the time period. */
    previousTotal?: string;
    /** The data available for the requested measure, split into daily buckets. */
    data: MeasureData[];
}

type ReportCategory = "spam" | "violation" | "legal" | "other";
/**
 * Reports filed against users and/or statuses, to be taken action on by moderators.
 * @see https://docs.joinmastodon.org/entities/Report/
 */
interface Report$1 {
    /** The ID of the report in the database. */
    id: string;
    /** Whether an action was taken yet. */
    actionTaken: boolean;
    /** When an action was taken against the report. */
    actionTakenAt?: string | null;
    /**
     * The generic reason for the report.
     *
     * `spam` = Unwanted or repetitive content
     *
     * `violation` = A specific rule was violated
     *
     * `other` = Some other reason
     */
    category: ReportCategory;
    /** The reason for the report. */
    comment: string;
    /** Whether the report was forwarded to a remote domain */
    forwarded: boolean;
    /** When the report was created */
    createdAt: string;
    /** IDs of statuses that have been attached to this report for additional context. */
    statusIds?: string[] | null;
    /** IDs of the rules that have been cited as a violation by this report. */
    ruleIds?: string[] | null;
    /** The account that was reported. */
    targetAccount: Account$1;
}

interface Rule {
    /** An identifier for the rule. */
    id: string;
    /** The rule to be followed. */
    text: string;
    /** Longer-form description of the rule. */
    hint: string;
}

/**
 * Admin-level information about a filed report.
 * @see https://docs.joinmastodon.org/entities/admin-report/
 */
interface Report {
    /** The ID of the report in the database. */
    id: string;
    /** The action taken to resolve this report. */
    actionTaken: boolean;
    /** When an action was taken, if this report is currently resolved. */
    actionTakenAt?: string | null;
    /** The category under which the report is classified */
    category: ReportCategory;
    /** An optional reason for reporting. */
    comment: string;
    /** Whether a report was forwarded to a remote instance. */
    forwarded: boolean;
    /** The time the report was filed. */
    createdAt: string;
    /** The time of last action on this report. */
    updatedAt: string;
    /** The account which filed the report. */
    account: Account$1;
    /** The account being reported. */
    targetAccount: Account$1;
    /** The account of the moderator assigned to this report. */
    assignedAccount?: Account$1 | null;
    /** The action taken by the moderator who handled the report. */
    actionTakenByAccount: Account$1;
    /** Statuses attached to the report, for context. */
    statuses: Status[];
    /** Rules attached to the report, for context. */
    rules: Rule[];
}

interface TagHistory {
    day: string;
    accounts: string;
    uses: string;
}
/**
 * @see https://docs.joinmastodon.org/entities/Tag/#admin
 */
interface Tag {
    /** The ID of the Tag in the database. */
    id: string;
    name: string;
    url: string;
    history: TagHistory[];
    /** Whether the hashtag has been approved to trend. */
    trendable: boolean;
    /** Whether the hashtag has not been disabled from auto-linking. */
    usable: boolean;
    /** Whether the hashtag has not been reviewed yet to approve or deny its trending. */
    requiresReview: boolean;
}

type index$7_Account = Account;
type index$7_CanonicalEmailBlock = CanonicalEmailBlock;
type index$7_Cohort = Cohort;
type index$7_CohortData = CohortData;
type index$7_CohortFrequency = CohortFrequency;
type index$7_Dimension = Dimension;
type index$7_DimensionData = DimensionData;
type index$7_DimensionKey = DimensionKey;
type index$7_DomainAllow = DomainAllow;
type index$7_EmailDomainBlock = EmailDomainBlock;
type index$7_EmailDomainBlockHistory = EmailDomainBlockHistory;
type index$7_Ip = Ip;
type index$7_IpBlock = IpBlock;
type index$7_IpBlockSeverity = IpBlockSeverity;
type index$7_Measure = Measure;
type index$7_MeasureData = MeasureData;
type index$7_MeasureKey = MeasureKey;
type index$7_Report = Report;
type index$7_Tag = Tag;
type index$7_TagHistory = TagHistory;
declare namespace index$7 {
  export type { index$7_Account as Account, index$7_CanonicalEmailBlock as CanonicalEmailBlock, index$7_Cohort as Cohort, index$7_CohortData as CohortData, index$7_CohortFrequency as CohortFrequency, index$7_Dimension as Dimension, index$7_DimensionData as DimensionData, index$7_DimensionKey as DimensionKey, index$7_DomainAllow as DomainAllow, DomainBlock$1 as DomainBlock, DomainBlockSeverity$1 as DomainBlockSeverity, index$7_EmailDomainBlock as EmailDomainBlock, index$7_EmailDomainBlockHistory as EmailDomainBlockHistory, index$7_Ip as Ip, index$7_IpBlock as IpBlock, index$7_IpBlockSeverity as IpBlockSeverity, index$7_Measure as Measure, index$7_MeasureData as MeasureData, index$7_MeasureKey as MeasureKey, index$7_Report as Report, index$7_Tag as Tag, index$7_TagHistory as TagHistory };
}

/**
 * Represents a weekly bucket of instance activity.
 * @see https://docs.joinmastodon.org/entities/activity/
 */
interface Activity {
    /** Midnight at the first day of the week. */
    week: string;
    /** Statuses created since the week began. */
    statuses: string;
    /** User logins since the week began. */
    logins: string;
    /** User registrations since the week began. */
    registrations: string;
}

interface Reaction {
    name: string;
    count: number;
    me: boolean;
    url: string;
    staticUrl: string;
}

interface AnnouncementAccount {
    id: string;
    username: string;
    url: string;
    acct: string;
}
interface AnnouncementStatus {
    id: string;
    url: string;
}
interface Announcement {
    id: string;
    content: string;
    startsAt: string;
    endsAt: string;
    allDay: boolean;
    publishedAt: string;
    updatedAt: string;
    mentions: AnnouncementAccount[];
    statuses: AnnouncementStatus[];
    tags: Tag$1[];
    emojis: CustomEmoji[];
    reactions: Reaction[];
}

/**
 * Represents the tree around a given status. Used for reconstructing threads of statuses.
 * @see https://docs.joinmastodon.org/entities/context/
 */
interface Context {
    /** Parents in the thread. */
    ancestors: Status[];
    /** Children in the thread. */
    descendants: Status[];
}

/**
 * Represents a conversation with "direct message" visibility.
 * @see https://docs.joinmastodon.org/entities/conversation/
 */
interface Conversation {
    /** Local database ID of the conversation. */
    id: string;
    /** Participants in the conversation. */
    accounts: Account$1[];
    /** Is the conversation currently marked as unread? */
    unread: boolean;
    /** The last status in the conversation, to be used for optional display. */
    lastStatus?: Status | null;
}

/**
 * Represents an extended description for the instance, to be shown on its about page.
 */
interface ExtendedDescription {
    /** The rendered HTML content of the extended description. */
    content: string;
    /** A timestamp of when the extended description was last updated. */
    updatedAt?: string | null;
}

/**
 * Represents a domain that is blocked by the instance.
 */
interface DomainBlock {
    /** The domain which is blocked. This may be obfuscated or partially censored. */
    domain: string;
    /** The SHA256 hash digest of the domain string. */
    digest: string;
    /** The level to which the domain is blocked. */
    severity: DomainBlockSeverity;
    /** An optional reason for the domain block. */
    comment?: string | null;
}
type DomainBlockSeverity = "silence" | "suspend";

/**
 * Represents a subset of your follows who also follow some other user.
 * @see https://docs.joinmastodon.org/entities/FamiliarFollowers/
 */
interface FamiliarFollowers {
    /** The ID of the Account in the database. */
    id: string;
    /** Accounts you follow that also follow this account. */
    accounts: Account$1[];
}

/**
 * Represents a hashtag that is featured on a profile.
 * @see https://docs.joinmastodon.org/entities/featuredtag/
 */
interface FeaturedTag {
    /** The internal ID of the featured tag in the database. */
    id: string;
    /** The name of the hashtag being featured. */
    name: string;
    /** The number of authored statuses containing this hashtag */
    statusesCount: number;
    /** The timestamp of the last authored status containing this hashtag. */
    lastStatusAt?: string | null;
}

type FilterContext = "home" | "notifications" | "public" | "thread" | "account";
/**
 * Represents a user-defined filter for determining which statuses should not be shown to the user.
 * @see https://docs.joinmastodon.org/entities/filter/
 */
interface Filter {
    /** The ID of the filter in the database. */
    id: string;
    /** The text to be filtered. */
    phrase: string;
    /** The contexts in which the filter should be applied. */
    context: FilterContext[];
    /** When the filter should no longer be applied */
    expiresAt?: string | null;
    /** Should matching entities in home and notifications be dropped by the server? */
    irreversible: boolean;
    /** Should the filter consider word boundaries? */
    wholeWord: boolean;
}

/**
 * Appeal against a moderation action.
 */
interface Appeal {
    /** Text of the appeal from the moderated account to the moderators. */
    text: string;
    /** State of the appeal. */
    state: AppealState;
}
type AppealState = "approved" | "rejected" | "pending";

/**
 * Moderation warning against a particular account.
 */
interface AccountWarning {
    /** The ID of the account warning in the database. */
    id: string;
    /** Action taken against the account. */
    action: AccountWarningAction;
    /** Message from the moderator to the target account. */
    text: string;
    /** List of status IDs that are relevant to the warning. When action is mark_statuses_as_sensitive or delete_statuses, those are the affected statuses. */
    statusIds: string[];
    /** Account against which a moderation decision has been taken. */
    targetAccount: Account$1;
    /** Appeal submitted by the target account, if any. */
    appeal?: Appeal | null;
    /** When the event took place. */
    createdAt: string;
}
type AccountWarningAction = "none" | "disable" | "mark_statuses_as_sensitive" | "delete_statuses" | "sensitive" | "silence" | "suspend";

/**
 * Summary of a moderation or block event that caused follow relationships to be severed.
 */
interface RelationshipSeveranceEvent {
    /** The ID of the relationship severance event in the database. */
    id: string;
    /** Type of event. */
    type: RelationshipSeveranceEventType;
    /** Whether the list of severed relationships is unavailable because the underlying issue has been purged. */
    purged: boolean;
    /** Number of followers that were removed as result of the event. */
    followersCount: number;
    /** Number of accounts the user stopped following as result of the event. */
    followingCount: number;
    /** Name of the target of the moderation/block event. This is either a domain name or a user handle, depending on the event type. */
    targetName: string;
    /** When the event took place. */
    createdAt: string;
}
type RelationshipSeveranceEventType = "domain_block" | "user_domain_block" | "account_suspension";

interface GroupedNotificationsResults {
    /** Accounts referenced by grouped notifications. */
    accounts: Account$1[];
    /** Partial accounts referenced by grouped notifications. Those are only returned when requesting grouped notifications with `expand_accounts=partial_avatars`. */
    partialAccounts?: PartialAccountWithAvatar[];
    /** Statuses referenced by grouped notifications. */
    statuses: Status[];
    /** The grouped notifications themselves. */
    notificationGroups: NotificationGroup[];
}
/** These are stripped-down versions of {@link Account} that only contain what is necessary to display a list of avatars, as well as a few other useful properties. The aim is to cut back on expensive server-side serialization and reduce the network payload size of notification groups. */
type PartialAccountWithAvatar = Pick<Account$1, "id" | "acct" | "url" | "avatar" | "avatarStatic" | "locked" | "bot">;
interface BaseNotificationGroup<T> {
    /** Group key identifying the grouped notifications. Should be treated as an opaque value. */
    groupKey: string;
    /** Total number of individual notifications that are part of this notification group. */
    notificationsCount: number;
    /** The type of event that resulted in the notifications in this group. */
    type: T;
    /** ID of the most recent notification in the group. */
    mostRecentNotificationId: string;
    /** ID of the oldest notification from this group represented within the current page. This is only returned when paginating through notification groups. Useful when polling new notifications. */
    pageMinId?: string;
    /** ID of the newest notification from this group represented within the current page. This is only returned when paginating through notification groups. Useful when polling new notifications. */
    pageMaxId?: string;
    /** Date at which the most recent notification from this group within the current page has been created. This is only returned when paginating through notification groups. */
    latestPageNotificationAt?: string;
    /** IDs of some of the accounts who most recently triggered notifications in this group. */
    sampleAccountIds: string;
    /** ID of the Status that was the object of the notification. Attached when type of the notification is favourite, reblog, status, mention, poll, or update. */
    statusId?: undefined | null;
    /** Report that was the object of the notification. Attached when type of the notification is admin.report. */
    report?: undefined | null;
    /** Summary of the event that caused follow relationships to be severed. Attached when type of the notification is severed_relationships. */
    event?: undefined | null;
    /** Moderation warning that caused the notification. Attached when type of the notification is moderation_warning. */
    moderationWarning?: undefined | null;
}
type NotificationGroupPlain<T> = BaseNotificationGroup<T>;
type NotificationGroupWithStatusId<T> = BaseNotificationGroup<T> & {
    /** ID of the Status that was the object of the notification. Attached when type of the notification is favourite, reblog, status, mention, poll, or update. */
    statusId: string;
};
type NotificationGroupWithReport<T> = BaseNotificationGroup<T> & {
    /** Report that was the object of the notification. Attached when type of the notification is admin.report. */
    report: Report$1;
};
type NotificationGroupWithEvent<T> = BaseNotificationGroup<T> & {
    /** Summary of the event that caused follow relationships to be severed. Attached when type of the notification is severed_relationships. */
    event: RelationshipSeveranceEvent;
};
type NotificationGroupWithModerationWarning<T> = BaseNotificationGroup<T> & {
    /** Moderation warning that caused the notification. Attached when type of the notification is moderation_warning. */
    moderationWarning: AccountWarning;
};
/** Someone mentioned you in their status */
type MentionNotificationGroup = NotificationGroupWithStatusId<"mention">;
/** Someone you enabled notifications for has posted a status */
type StatusNotificationGroup = NotificationGroupWithStatusId<"status">;
/** Someone boosted one of your statuses */
type ReblogNotificationGroup = NotificationGroupWithStatusId<"reblog">;
/** Someone followed you */
type FollowNotificationGroup = NotificationGroupPlain<"follow">;
/** Someone requested to follow you */
type FollowRequestNotificationGroup = NotificationGroupPlain<"follow_request">;
/**  Someone favourited one of your statuses */
type FavouriteNotificationGroup = NotificationGroupWithStatusId<"favourite">;
/** A poll you have voted in or created has ended */
type PollNotificationGroup = NotificationGroupWithStatusId<"poll">;
/** A status you interacted with has been edited */
type UpdateNotificationGroup = NotificationGroupWithStatusId<"update">;
/** Someone signed up (optionally sent to admins) */
type AdminSignUpNotificationGroup = NotificationGroupPlain<"admin.sign_up">;
/** A new report has been filed */
type AdminReportNotificationGroup = NotificationGroupWithReport<"admin.report">;
/** Some of your follow relationships have been severed as a result of a moderation or block event */
type SeveredRelationshipsNotificationGroup = NotificationGroupWithEvent<"severed_relationships">;
/** A moderator has taken action against your account or has sent you a warning */
type ModerationWarningNotificationGroup = NotificationGroupWithModerationWarning<"moderation_warning">;
/** Group key identifying the grouped notifications. Should be treated as an opaque value. */
type NotificationGroup = MentionNotificationGroup | StatusNotificationGroup | ReblogNotificationGroup | FollowNotificationGroup | FollowRequestNotificationGroup | FavouriteNotificationGroup | PollNotificationGroup | UpdateNotificationGroup | AdminSignUpNotificationGroup | AdminReportNotificationGroup | SeveredRelationshipsNotificationGroup | ModerationWarningNotificationGroup;
type NotificationGroupType = NotificationGroup["type"];

/**
 * Represents a proof from an external identity provider.
 * @see https://docs.joinmastodon.org/entities/identityproof/
 */
interface IdentityProof {
    /** The name of the identity provider. */
    provider: string;
    /** The account owner's username on the identity provider's service. */
    providerUsername: string;
    /** The account owner's profile URL on the identity provider. */
    profileUrl: string;
    /** A link to a statement of identity proof, hosted by the identity provider. */
    proofUrl: string;
    /** The name of the identity provider. */
    updatedAt: string;
}

interface InstanceStatusesConfiguration$1 {
    maxCharacters: number;
    maxMediaAttachments: number;
    charactersReservedPerUrl: number;
}
interface InstanceMediaAttachmentsConfiguration$1 {
    supportedMimeTypes: string[];
    imageSizeLimit: number;
    imageMatrixLimit: number;
    videoSizeLimit: number;
    videoFrameRateLimit: number;
    videoMatrixLimit: number;
}
interface InstancePollsConfiguration$1 {
    maxOptions: number;
    maxCharactersPerOption: number;
    minExpiration: number;
    maxExpiration: number;
}
interface InstanceAccountsConfiguration$1 {
    maxFeaturedTags: number;
}
/**
 * @see https://github.com/mastodon/mastodon/pull/16485
 */
interface InstanceConfiguration$1 {
    statuses: InstanceStatusesConfiguration$1;
    mediaAttachments: InstanceMediaAttachmentsConfiguration$1;
    polls: InstancePollsConfiguration$1;
    accounts: InstanceAccountsConfiguration$1;
}
/**
 * Represents the software instance of Mastodon running on this domain.
 * @see https://docs.joinmastodon.org/entities/instance/
 */
interface Instance$1 {
    /** The domain name of the instance. */
    uri: string;
    /** The title of the website. */
    title: string;
    /** Admin-defined description of the Mastodon site. */
    description: string;
    /** A shorter description defined by the admin. */
    shortDescription: string;
    /** An email that may be contacted for any inquiries. */
    email: string;
    /** The version of Mastodon installed on the instance. */
    version: string;
    /** Primary languages of the website and its staff. */
    languages: string[];
    /** Whether registrations are enabled. */
    registrations: boolean;
    /** Whether registrations require moderator approval. */
    approvalRequired: boolean;
    /** URLs of interest for clients apps. */
    urls: InstanceURLs;
    /** Statistics about how much information the instance contains. */
    stats: InstanceStats;
    /** Whether invitation in enabled */
    invitesEnabled: boolean;
    /** List various values like file size limits and supported mime types */
    configuration: InstanceConfiguration$1;
    /** Banner image for the website. */
    thumbnail?: string | null;
    /** A user that can be contacted, as an alternative to `email`. */
    contactAccount?: Account$1 | null;
    rules?: Rule[] | null;
}
interface InstanceURLs {
    /** WebSockets address for push streaming. String (URL). */
    streamingApi: string;
}
interface InstanceStats {
    /** Users registered on this instance. Number. */
    userCount: number;
    /** Statuses authored by users on instance. Number. */
    statusCount: number;
    /** Domains federated with this instance. Number. */
    domainCount: number;
}

type ListRepliesPolicy = "followed" | "list" | "none";
/**
 * Represents a list of some users that the authenticated user follows.
 * @see https://docs.joinmastodon.org/entities/list/
 */
interface List {
    /** The internal database ID of the list. */
    id: string;
    /** The user-defined title of the list. */
    title: string;
    /**
     * Which replies should be shown in the list.
     *
     * `followed` = Show replies to any followed user
     *
     * `list` = Show replies to members of the list
     *
     * `none` = Show replies to no one
     */
    repliesPolicy: ListRepliesPolicy;
    /** https://github.com/mastodon/mastodon/pull/22048/files */
    exclusive: boolean;
}

interface MarkerItem {
    /** The ID of the most recently viewed entity. */
    lastReadId: string;
    /** The timestamp of when the marker was set. */
    updatedAt: string;
    /** Used for locking to prevent write conflicts. */
    version: number;
}
type MarkerTimeline = "home" | "notifications";
/**
 * Represents the last read position within a user's timelines.
 * @see https://docs.joinmastodon.org/entities/marker/
 */
type Marker = {
    [key in MarkerTimeline]: MarkerItem;
};

interface BaseNotification<T> {
    /** The id of the notification in the database. */
    id: string;
    /** The type of event that resulted in the notification. */
    type: T;
    /** The timestamp of the notification. */
    createdAt: string;
    /** The account that performed the action that generated the notification. */
    account: Account$1;
    /** Group key shared by similar notifications, to be used in the grouped notifications feature. Should be considered opaque, but ungrouped notifications can be assumed to have a group_key of the form ungrouped-{notification_id} */
    groupKey: string;
}
type BaseNotificationPlain<T> = BaseNotification<T> & {
    /** Status that was the object of the notification, e.g. in mentions, reblogs, favourites, or polls. */
    status?: undefined | null;
    /** Report that was the object of the notification. Attached when type of the notification is admin.report. */
    report?: undefined | null;
};
type BaseNotificationWithStatus<T> = BaseNotification<T> & {
    /** Status that was the object of the notification, e.g. in mentions, reblogs, favourites, or polls. */
    status: Status;
    /** Report that was the object of the notification. Attached when type of the notification is admin.report. */
    report?: undefined | null;
};
type BaseNotificationWithReport<T> = BaseNotification<T> & {
    /** Status that was the object of the notification, e.g. in mentions, reblogs, favourites, or polls. */
    status?: undefined | null;
    /** Report that was the object of the notification. Attached when type of the notification is admin.report. */
    report: Report$1;
};
/**
 * Someone mentioned you in their status
 */
type MentionNotification = BaseNotificationWithStatus<"mention">;
/**
 * Someone you enabled notifications for has posted a status
 */
type StatusNotification = BaseNotificationWithStatus<"status">;
/**
 * Someone boosted one of your statuses
 */
type ReblogNotification = BaseNotificationWithStatus<"reblog">;
/**
 * Someone followed you
 */
type FollowNotification = BaseNotificationPlain<"follow">;
/**
 * Someone requested to follow you
 */
type FollowRequestNotification = BaseNotificationPlain<"follow_request">;
/**
 * Someone favourited one of your statuses
 */
type FavouriteNotification = BaseNotificationWithStatus<"favourite">;
/**
 * A poll you have voted in or created has ended
 */
type PollNotification = BaseNotificationWithStatus<"poll">;
/**
 * A status you interacted with has been edited
 */
type UpdateNotification = BaseNotificationWithStatus<"update">;
/**
 * Someone signed up (optionally sent to admins)
 */
type AdminSignUpNotification = BaseNotificationPlain<"admin.sign_up">;
type AdminReportNotification = BaseNotificationWithReport<"admin.report">;
/**
 * Some of your follow relationships have been severed as a result of a moderation or block event
 */
type SeveredRelationshipsNotification = BaseNotificationPlain<"severed_relationships"> & {
    event: RelationshipSeveranceEvent;
};
/**
 * A moderator has taken action against your account or has sent you a warning
 */
type ModerationWarningNotification = BaseNotificationPlain<"moderation_warning"> & {
    moderationWarning: AccountWarning;
};
/**
 * Represents a notification of an event relevant to the user.
 * @see https://docs.joinmastodon.org/entities/notification
 */
type Notification = MentionNotification | StatusNotification | ReblogNotification | FollowNotification | FollowRequestNotification | FavouriteNotification | PollNotification | UpdateNotification | AdminSignUpNotification | AdminReportNotification | SeveredRelationshipsNotification | ModerationWarningNotification;
type NotificationType = Notification["type"];

interface NotificationRequest {
    /** The id of the notification request in the database. */
    id: string;
    /** The timestamp of the notification request, i.e. when the first filtered notification from that user was created. */
    createdAt: string;
    /** The timestamp of when the notification request was last updated. */
    updatedAt: string;
    /** The account that performed the action that generated the filtered notifications. */
    account: Account$1;
    /** How many of this account’s notifications were filtered. */
    notificationsCount: number;
    /** Most recent status associated with a filtered notification from that account. */
    lastStatus?: Status | null;
}

type PreferenceReadingExpandMedia = "show_all" | "hide_all" | "default";
/**
 * Represents a user's preferences.
 * @see https://docs.joinmastodon.org/entities/preferences/
 */
interface Preference {
    /** Default visibility for new posts. Equivalent to Source#privacy. */
    "posting:default:visibility": StatusVisibility;
    /** Default sensitivity flag for new posts. Equivalent to Source#sensitive. */
    "posting:default:sensitive": boolean;
    /** Default language for new posts. Equivalent to Source#language */
    "posting:default:language": string;
    /** Whether media attachments should be automatically displayed or blurred/hidden. */
    "reading:expand:media": PreferenceReadingExpandMedia;
    /** Whether CWs should be expanded by default. */
    "reading:expand:spoilers": boolean;
    /** Whether GIFs should be automatically played */
    "reading:autoplay:gifs": boolean;
}

/**
 * Represents the relationship between accounts, such as following / blocking / muting / etc.
 * @see https://docs.joinmastodon.org/entities/relationship/
 */
interface Relationship {
    /** The account id. */
    id: string;
    /** Are you following this user? */
    following: boolean;
    /** Are you receiving this user's boosts in your home timeline? */
    showingReblogs: boolean;
    /** Have you enabled notifications for this user? */
    notifying: boolean;
    /** Which languages are you following from this user? */
    languages: string[];
    /** Are you followed by this user? */
    followedBy: boolean;
    /** Are you blocking this user? */
    blocking: boolean;
    /** Is this user blocking you? */
    blockedBy: boolean;
    /** Are you muting this user? */
    muting: boolean;
    /** Are you muting notifications from this user? */
    mutingNotifications: boolean;
    /** Do you have a pending follow request for this user? */
    requested: boolean;
    /** Are you blocking this user's domain? */
    domainBlocking: boolean;
    /** Are you featuring this user on your profile? */
    endorsed: boolean;
    /** Personal note for this account */
    note?: string | null;
    /** Whether the represented user has requested to follow you */
    requestedBy: boolean;
}

interface StatusParams extends Pick<Status, "id" | "inReplyToId" | "sensitive" | "spoilerText" | "visibility"> {
    /** Content of the status */
    text: string;
    /** IDs of media attachments */
    mediaIds?: string[] | null;
    /** ID of the application */
    applicationId: string;
}
/**
 * Represents a status that will be published at a future scheduled date.
 * @see https://docs.joinmastodon.org/entities/scheduledstatus/
 */
interface ScheduledStatus {
    /** ID of the scheduled status in the database. */
    id: string;
    /** ID of the status in the database. */
    scheduledAt: string;
    /** Parameters of the status */
    params: StatusParams;
    /** Media attachments */
    mediaAttachments: MediaAttachment[];
}

/**
 * Represents the results of a search.
 * @see https://docs.joinmastodon.org/entities/results/
 */
interface Search$1 {
    /** Accounts which match the given query */
    accounts: Account$1[];
    /** Statuses which match the given query */
    statuses: Status[];
    /** Hashtags which match the given query */
    hashtags: string[];
}

type StatusEdit = Pick<Status, "content" | "spoilerText" | "sensitive" | "createdAt" | "account" | "mediaAttachments" | "emojis">;

interface StatusSource {
    id: string;
    text: string;
    spoilerText: string;
}

/**
 * `staff` = This account was manually recommended by your administration team
 * `past_interactions` = You have interacted with this account previously
 * `global` = This account has many reblogs, favourites, and active local followers within the last 30 days
 *
 * @deprecated Use {@link SuggestionSource_} instead
 */
type SuggestionSource = "staff" | "past_interactions" | "global";
/**
 * `featured` = This account was manually recommended by your administration team. Equivalent to the staff value for source
 *
 * `most_followed` = This account has many active local followers
 *
 * `most_interactions` = This account had many reblogs and favourites within the last 30 days
 *
 * `similar_to_recently_followed` = This account’s profile is similar to your most recent follows
 *
 * `friends_of_friends`  = This account is followed by people you follow
 */
type SuggestionSource_ = "featured" | "most_followed" | "most_interactions" | "similar_to_recently_followed" | "friends_of_friends";
/**
 * Represents a suggested account to follow and an associated reason for the suggestion.
 * @see https://docs.joinmastodon.org/entities/Suggestion/
 */
interface Suggestion {
    /**
     * The reason this account is being suggested.
     * @deprecated
     */
    source: SuggestionSource;
    /** A list of reasons this account is being suggested. This replaces source */
    sources: SuggestionSource_[];
    /**
     * The account being recommended to follow.
     */
    account: Account$1;
}

/**
 * Represents an OAuth token used for authenticating with the API and performing actions.
 * @see https://docs.joinmastodon.org/entities/token/
 */
interface Token {
    /** An OAuth token to be used for authorization. */
    accessToken: string;
    /** The OAuth token type. Mastodon uses Bearer tokens. */
    tokenType: string;
    /** The OAuth scopes granted by this token, space-separated. */
    scope: string;
    /** When the token was generated. */
    createdAt: number;
}

interface Translation {
    /** The translated text of the status. */
    content: string;
    /** The language of the source text, as auto-detected by the machine translation provider. */
    detectedLanguageSource: string;
    /** The service that provided the machine translation. */
    provider: string;
}

type WebPushSubscriptionPolicy = "all" | "followed" | "follower" | "none";
/**
 * Represents a subscription to the push streaming server.
 * @see https://docs.joinmastodon.org/entities/WebPushSubscription/
 */
interface WebPushSubscription {
    /** The id of the push subscription in the database. */
    id: string;
    /** Where push alerts will be sent to. */
    endpoint: string;
    /** The streaming server's VAPID key. */
    serverKey: string;
    /** Which alerts should be delivered to the `endpoint`. */
    alerts: WebPushSubscriptionAlerts;
    policy: WebPushSubscriptionPolicy;
}
interface WebPushSubscriptionAlerts {
    /** Receive a push notification when someone has followed you? Boolean. */
    follow: boolean;
    /** Receive a push notification when a status you created has been favourited by someone else? Boolean. */
    favourite: boolean;
    /** Receive a push notification when someone else has mentioned you in a status? Boolean. */
    reblog: boolean;
    /** Receive a push notification when a status you created has been boosted by someone else? Boolean. */
    mention: boolean;
    /** Receive a push notification when a poll you voted in or created has ended? Boolean. */
    poll: boolean;
    /** Receive new subscribed account notifications? Defaults to false. */
    status: boolean;
    /** Receive status edited notifications? Defaults to false. */
    update: boolean;
    admin: {
        /** Receive new user signup notifications? Defaults to false. Must have a role with the appropriate permissions. */
        signUp: boolean;
        /** Receive new report notifications? Defaults to false. Must have a role with the appropriate permissions. */
        report: boolean;
    };
}

type index$6_AccountCredentials = AccountCredentials;
type index$6_AccountField = AccountField;
type index$6_AccountSource = AccountSource;
type index$6_Activity = Activity;
type index$6_AdminReportNotification = AdminReportNotification;
type index$6_AdminReportNotificationGroup = AdminReportNotificationGroup;
type index$6_AdminSignUpNotification = AdminSignUpNotification;
type index$6_AdminSignUpNotificationGroup = AdminSignUpNotificationGroup;
type index$6_Announcement = Announcement;
type index$6_AnnouncementAccount = AnnouncementAccount;
type index$6_AnnouncementStatus = AnnouncementStatus;
type index$6_Application = Application;
type index$6_Context = Context;
type index$6_Conversation = Conversation;
type index$6_CustomEmoji = CustomEmoji;
type index$6_DomainBlock = DomainBlock;
type index$6_DomainBlockSeverity = DomainBlockSeverity;
type index$6_ExtendedDescription = ExtendedDescription;
type index$6_FamiliarFollowers = FamiliarFollowers;
type index$6_FavouriteNotification = FavouriteNotification;
type index$6_FavouriteNotificationGroup = FavouriteNotificationGroup;
type index$6_FeaturedTag = FeaturedTag;
type index$6_Filter = Filter;
type index$6_FilterContext = FilterContext;
type index$6_FilterKeyword = FilterKeyword;
type index$6_FilterResult = FilterResult;
type index$6_FilterStatus = FilterStatus;
type index$6_FollowNotification = FollowNotification;
type index$6_FollowNotificationGroup = FollowNotificationGroup;
type index$6_FollowRequestNotification = FollowRequestNotification;
type index$6_FollowRequestNotificationGroup = FollowRequestNotificationGroup;
type index$6_GroupedNotificationsResults = GroupedNotificationsResults;
type index$6_IdentityProof = IdentityProof;
type index$6_InstanceStats = InstanceStats;
type index$6_InstanceURLs = InstanceURLs;
type index$6_List = List;
type index$6_ListRepliesPolicy = ListRepliesPolicy;
type index$6_Marker = Marker;
type index$6_MarkerItem = MarkerItem;
type index$6_MarkerTimeline = MarkerTimeline;
type index$6_MediaAttachment = MediaAttachment;
type index$6_MediaAttachmentMeta = MediaAttachmentMeta;
type index$6_MediaAttachmentMetaColors = MediaAttachmentMetaColors;
type index$6_MediaAttachmentMetaFocus = MediaAttachmentMetaFocus;
type index$6_MediaAttachmentMetaImage = MediaAttachmentMetaImage;
type index$6_MediaAttachmentMetaVideo = MediaAttachmentMetaVideo;
type index$6_MediaAttachmentType = MediaAttachmentType;
type index$6_MentionNotification = MentionNotification;
type index$6_MentionNotificationGroup = MentionNotificationGroup;
type index$6_ModerationWarningNotification = ModerationWarningNotification;
type index$6_ModerationWarningNotificationGroup = ModerationWarningNotificationGroup;
type index$6_Notification = Notification;
type index$6_NotificationGroup = NotificationGroup;
type index$6_NotificationGroupType = NotificationGroupType;
type index$6_NotificationRequest = NotificationRequest;
type index$6_NotificationType = NotificationType;
type index$6_PartialAccountWithAvatar = PartialAccountWithAvatar;
type index$6_Poll = Poll;
type index$6_PollNotification = PollNotification;
type index$6_PollNotificationGroup = PollNotificationGroup;
type index$6_PollOption = PollOption;
type index$6_Preference = Preference;
type index$6_PreferenceReadingExpandMedia = PreferenceReadingExpandMedia;
type index$6_PreviewCard = PreviewCard;
type index$6_PreviewCardAuthor = PreviewCardAuthor;
type index$6_PreviewCardType = PreviewCardType;
type index$6_Reaction = Reaction;
type index$6_ReblogNotification = ReblogNotification;
type index$6_ReblogNotificationGroup = ReblogNotificationGroup;
type index$6_Relationship = Relationship;
type index$6_RelationshipSeveranceEvent = RelationshipSeveranceEvent;
type index$6_RelationshipSeveranceEventType = RelationshipSeveranceEventType;
type index$6_ReportCategory = ReportCategory;
type index$6_Role = Role;
type index$6_Rule = Rule;
type index$6_ScheduledStatus = ScheduledStatus;
type index$6_SeveredRelationshipsNotification = SeveredRelationshipsNotification;
type index$6_SeveredRelationshipsNotificationGroup = SeveredRelationshipsNotificationGroup;
type index$6_Status = Status;
type index$6_StatusEdit = StatusEdit;
type index$6_StatusMention = StatusMention;
type index$6_StatusNotification = StatusNotification;
type index$6_StatusNotificationGroup = StatusNotificationGroup;
type index$6_StatusParams = StatusParams;
type index$6_StatusSource = StatusSource;
type index$6_StatusVisibility = StatusVisibility;
type index$6_Suggestion = Suggestion;
type index$6_SuggestionSource = SuggestionSource;
type index$6_SuggestionSource_ = SuggestionSource_;
type index$6_Token = Token;
type index$6_Translation = Translation;
type index$6_TrendLink = TrendLink;
type index$6_UpdateNotification = UpdateNotification;
type index$6_UpdateNotificationGroup = UpdateNotificationGroup;
type index$6_WebPushSubscription = WebPushSubscription;
type index$6_WebPushSubscriptionAlerts = WebPushSubscriptionAlerts;
type index$6_WebPushSubscriptionPolicy = WebPushSubscriptionPolicy;
declare namespace index$6 {
  export { type Account$1 as Account, type index$6_AccountCredentials as AccountCredentials, type index$6_AccountField as AccountField, type index$6_AccountSource as AccountSource, type index$6_Activity as Activity, index$7 as Admin, type index$6_AdminReportNotification as AdminReportNotification, type index$6_AdminReportNotificationGroup as AdminReportNotificationGroup, type index$6_AdminSignUpNotification as AdminSignUpNotification, type index$6_AdminSignUpNotificationGroup as AdminSignUpNotificationGroup, type index$6_Announcement as Announcement, type index$6_AnnouncementAccount as AnnouncementAccount, type index$6_AnnouncementStatus as AnnouncementStatus, type index$6_Application as Application, type Client$3 as Client, type index$6_Context as Context, type index$6_Conversation as Conversation, type index$6_CustomEmoji as CustomEmoji, type index$6_DomainBlock as DomainBlock, type index$6_DomainBlockSeverity as DomainBlockSeverity, type index$6_ExtendedDescription as ExtendedDescription, type index$6_FamiliarFollowers as FamiliarFollowers, type index$6_FavouriteNotification as FavouriteNotification, type index$6_FavouriteNotificationGroup as FavouriteNotificationGroup, type index$6_FeaturedTag as FeaturedTag, type index$6_Filter as Filter, type index$6_FilterContext as FilterContext, type index$6_FilterKeyword as FilterKeyword, type index$6_FilterResult as FilterResult, type index$6_FilterStatus as FilterStatus, type index$6_FollowNotification as FollowNotification, type index$6_FollowNotificationGroup as FollowNotificationGroup, type index$6_FollowRequestNotification as FollowRequestNotification, type index$6_FollowRequestNotificationGroup as FollowRequestNotificationGroup, type index$6_GroupedNotificationsResults as GroupedNotificationsResults, type index$6_IdentityProof as IdentityProof, type Instance$1 as Instance, type InstanceAccountsConfiguration$1 as InstanceAccountsConfiguration, type InstanceConfiguration$1 as InstanceConfiguration, type InstanceMediaAttachmentsConfiguration$1 as InstanceMediaAttachmentsConfiguration, type InstancePollsConfiguration$1 as InstancePollsConfiguration, type index$6_InstanceStats as InstanceStats, type InstanceStatusesConfiguration$1 as InstanceStatusesConfiguration, type index$6_InstanceURLs as InstanceURLs, type index$6_List as List, type index$6_ListRepliesPolicy as ListRepliesPolicy, type index$6_Marker as Marker, type index$6_MarkerItem as MarkerItem, type index$6_MarkerTimeline as MarkerTimeline, type index$6_MediaAttachment as MediaAttachment, type index$6_MediaAttachmentMeta as MediaAttachmentMeta, type index$6_MediaAttachmentMetaColors as MediaAttachmentMetaColors, type index$6_MediaAttachmentMetaFocus as MediaAttachmentMetaFocus, type index$6_MediaAttachmentMetaImage as MediaAttachmentMetaImage, type index$6_MediaAttachmentMetaVideo as MediaAttachmentMetaVideo, type index$6_MediaAttachmentType as MediaAttachmentType, type index$6_MentionNotification as MentionNotification, type index$6_MentionNotificationGroup as MentionNotificationGroup, type index$6_ModerationWarningNotification as ModerationWarningNotification, type index$6_ModerationWarningNotificationGroup as ModerationWarningNotificationGroup, type index$6_Notification as Notification, type index$6_NotificationGroup as NotificationGroup, type index$6_NotificationGroupType as NotificationGroupType, type index$6_NotificationRequest as NotificationRequest, type index$6_NotificationType as NotificationType, type index$6_PartialAccountWithAvatar as PartialAccountWithAvatar, type index$6_Poll as Poll, type index$6_PollNotification as PollNotification, type index$6_PollNotificationGroup as PollNotificationGroup, type index$6_PollOption as PollOption, type index$6_Preference as Preference, type index$6_PreferenceReadingExpandMedia as PreferenceReadingExpandMedia, type index$6_PreviewCard as PreviewCard, type index$6_PreviewCardAuthor as PreviewCardAuthor, type index$6_PreviewCardType as PreviewCardType, type index$6_Reaction as Reaction, type index$6_ReblogNotification as ReblogNotification, type index$6_ReblogNotificationGroup as ReblogNotificationGroup, type index$6_Relationship as Relationship, type index$6_RelationshipSeveranceEvent as RelationshipSeveranceEvent, type index$6_RelationshipSeveranceEventType as RelationshipSeveranceEventType, type Report$1 as Report, type index$6_ReportCategory as ReportCategory, type index$6_Role as Role, type index$6_Rule as Rule, type index$6_ScheduledStatus as ScheduledStatus, type Search$1 as Search, type index$6_SeveredRelationshipsNotification as SeveredRelationshipsNotification, type index$6_SeveredRelationshipsNotificationGroup as SeveredRelationshipsNotificationGroup, type index$6_Status as Status, type index$6_StatusEdit as StatusEdit, type index$6_StatusMention as StatusMention, type index$6_StatusNotification as StatusNotification, type index$6_StatusNotificationGroup as StatusNotificationGroup, type index$6_StatusParams as StatusParams, type index$6_StatusSource as StatusSource, type index$6_StatusVisibility as StatusVisibility, type index$6_Suggestion as Suggestion, type index$6_SuggestionSource as SuggestionSource, type index$6_SuggestionSource_ as SuggestionSource_, type Tag$1 as Tag, type TagHistory$1 as TagHistory, type index$6_Token as Token, type index$6_Translation as Translation, type index$6_TrendLink as TrendLink, type index$6_UpdateNotification as UpdateNotification, type index$6_UpdateNotificationGroup as UpdateNotificationGroup, type index$6_WebPushSubscription as WebPushSubscription, type index$6_WebPushSubscriptionAlerts as WebPushSubscriptionAlerts, type index$6_WebPushSubscriptionPolicy as WebPushSubscriptionPolicy };
}

interface InstanceUsageUsers {
    /** The number of active users in the past 4 weeks. */
    activeMonth: number;
}
interface InstanceUsage {
    /** Usage data related to users on this instance. */
    users: InstanceUsageUsers;
}
interface InstanceThumbnailVersions {
    /** The URL for the thumbnail image at 1x resolution. */
    "@1x": string;
    /** The URL for the thumbnail image at 2x resolution. */
    "@2x": string;
}
interface InstanceThumbnail {
    /** The URL for the thumbnail image. */
    url: string;
    /** A hash computed by [the BlurHash algorithm](https://github.com/woltapp/blurhash), for generating colorful preview thumbnails when media has not been downloaded yet. */
    blurhash: string;
    /** Links to scaled resolution images, for high DPI screens. */
    versions: InstanceThumbnailVersions;
}
interface InstanceUrls {
    /** The WebSockets URL for connecting to the streaming API. */
    streaming: string;
    /** Instance status URL */
    status?: string;
}
interface InstanceAccountsConfiguration {
    /** The maximum number of featured tags allowed for each account. */
    maxFeaturedTags: number;
    /** The maximum number of pinned statuses for each account. */
    maxPinnedStatuses: number;
}
interface InstanceStatusesConfiguration {
    /** The maximum number of allowed characters per status. */
    maxCharacters: number;
    /** The maximum number of media attachments that can be added to a status. */
    maxMediaAttachments: number;
    /** Each URL in a status will be assumed to be exactly this many characters. */
    charactersReservedPerUrl: number;
}
interface InstanceMediaAttachmentsConfiguration {
    /** Contains MIME types that can be uploaded. */
    supportedMimeTypes: string[];
    /** The maximum size of any uploaded image, in bytes. */
    imageSizeLimit: number;
    /** The maximum number of pixels (width times height) for image uploads. */
    imageMatrixLimit: number;
    /** The maximum size of any uploaded video, in bytes. */
    videoSizeLimit: number;
    /** The maximum frame rate for any uploaded video. */
    videoFrameRateLimit: number;
    /** The maximum number of pixels (width times height) for video uploads. */
    videoMatrixLimit: number;
}
interface InstancePollsConfiguration {
    /** Each poll is allowed to have up to this many options. */
    maxOptions: number;
    /** Each poll option is allowed to have this many characters. */
    maxCharactersPerOption: number;
    /** The shortest allowed poll duration, in seconds. */
    minExpiration: number;
    /** The longest allowed poll duration, in seconds. */
    maxExpiration: number;
}
interface InstanceTranslationConfiguration {
    /** Whether the Translations API is available on this instance. */
    enabled: boolean;
}
interface InstanceVapidConfiguration {
    /** The instances VAPID public key, used for push notifications, the same as */
    publicKey: string;
}
interface InstanceConfiguration {
    /** URLs of interest for clients apps. */
    urls: InstanceUrls;
    /** Limits related to accounts. */
    accounts: InstanceAccountsConfiguration;
    /** Limits related to authoring statuses. */
    statuses: InstanceStatusesConfiguration;
    /** Hints for which attachments will be accepted. */
    mediaAttachments: InstanceMediaAttachmentsConfiguration;
    /** Limits related to polls. */
    polls: InstancePollsConfiguration;
    /** Hints related to translation. */
    translation: InstanceTranslationConfiguration;
    vapid: InstanceVapidConfiguration;
}
interface InstanceRegistrations {
    /** Whether registrations are enabled. */
    enabled: boolean;
    /** Whether registrations require moderator approval. */
    approvalRequired: boolean;
    /** A custom message to be shown when registrations are closed. */
    message?: string | null;
}
interface InstanceContact {
    /** An email address that can be messaged regarding inquiries or issues. */
    email: string;
    /** An account that can be contacted natively over the network regarding inquiries or issues. */
    account: Account$1;
}
interface InstanceApiVersions {
    /** API version number that this server implements. Starting from Mastodon v4.3.0, API changes will come with a version number, which clients can check against this value. */
    mastodon: string;
}
interface InstanceIcon {
    /** The URL of this icon. */
    src: string;
    /** The size of this icon. */
    size: string;
}
/**
 * Represents the software instance of Mastodon running on this domain.
 * @see https://docs.joinmastodon.org/entities/Instance/
 */
interface Instance {
    /** The domain name of the instance. */
    domain: string;
    /** The title of the website. */
    title: string;
    /** The version of Mastodon installed on the instance. */
    version: string;
    /** The URL for the source code of the software running on this instance, in keeping with AGPL license requirements. */
    sourceUrl: string;
    /** A short, plain-text description defined by the admin. */
    description: string;
    /** Usage data for this instance. */
    usage: InstanceUsage;
    /** An image used to represent this instance */
    thumbnail: InstanceThumbnail;
    /** The list of available size variants for this instance configured icon. */
    icon: InstanceIcon[];
    /** Primary languages of the website and its staff. */
    languages: string[];
    /** Configured values and limits for this website. */
    configuration: InstanceConfiguration;
    /** Information about registering for this website. */
    registrations: InstanceRegistrations;
    /** Information about which version of the API is implemented by this server. It contains at least a mastodon attribute, and other implementations may have their own additional attributes. */
    apiVersions: InstanceApiVersions;
    /** Hints related to contacting a representative of the website. */
    contact: InstanceContact;
    /** An itemized list of rules for this website. */
    rules: Rule[];
}

type NotificationPolicyType = "accept" | "filter" | "drop";
/**
 * Represents the notification filtering policy of the user.
 */
interface NotificationPolicy {
    /** Whether to filter notifications from accounts the user is not following. */
    forNotFollowing: NotificationPolicyType;
    /** Whether to filter notifications from accounts that are not following the user. */
    forNotFollowers: NotificationPolicyType;
    /** Whether to filter notifications from accounts created in the past 30 days. */
    forNewAccounts: NotificationPolicyType;
    /** Whether to filter notifications from private mentions. Replies to private mentions initiated by the user, as well as accounts the user follows, are never filtered. */
    forPrivateMentions: NotificationPolicyType;
    /** Whether to accept, filter or drop notifications from accounts that were limited by a moderator. drop will prevent creation of the notification object altogether (without preventing the underlying activity), filter will cause it to be marked as filtered, and accept will not affect its processing. Type: String (one of accept, filter or drop) */
    forLimitedAccounts: NotificationPolicyType;
    /** Summary of the filtered notifications */
    summary: {
        /** Number of different accounts from which the user has non-dismissed filtered notifications. Capped at 100. Type: Integer */
        pendingRequestsCount: number;
        /** Number of total non-dismissed filtered notifications. May be inaccurate.  */
        pendingNotificationsCount: number;
    };
}

/**
 * Represents the results of a search.
 * @see https://docs.joinmastodon.org/entities/Search/
 */
interface Search {
    /** Accounts which match the given query */
    accounts: Account$1[];
    /** Statuses which match the given query */
    statuses: Status[];
    /** Hashtags which match the given query */
    hashtags: Tag$1[];
}

type index$5_FilterAction = FilterAction;
type index$5_Instance = Instance;
type index$5_InstanceAccountsConfiguration = InstanceAccountsConfiguration;
type index$5_InstanceApiVersions = InstanceApiVersions;
type index$5_InstanceConfiguration = InstanceConfiguration;
type index$5_InstanceContact = InstanceContact;
type index$5_InstanceIcon = InstanceIcon;
type index$5_InstanceMediaAttachmentsConfiguration = InstanceMediaAttachmentsConfiguration;
type index$5_InstancePollsConfiguration = InstancePollsConfiguration;
type index$5_InstanceRegistrations = InstanceRegistrations;
type index$5_InstanceStatusesConfiguration = InstanceStatusesConfiguration;
type index$5_InstanceThumbnail = InstanceThumbnail;
type index$5_InstanceThumbnailVersions = InstanceThumbnailVersions;
type index$5_InstanceTranslationConfiguration = InstanceTranslationConfiguration;
type index$5_InstanceUrls = InstanceUrls;
type index$5_InstanceUsage = InstanceUsage;
type index$5_InstanceUsageUsers = InstanceUsageUsers;
type index$5_InstanceVapidConfiguration = InstanceVapidConfiguration;
type index$5_NotificationPolicy = NotificationPolicy;
type index$5_NotificationPolicyType = NotificationPolicyType;
type index$5_Search = Search;
declare namespace index$5 {
  export type { Filter$1 as Filter, index$5_FilterAction as FilterAction, FilterContext$1 as FilterContext, index$5_Instance as Instance, index$5_InstanceAccountsConfiguration as InstanceAccountsConfiguration, index$5_InstanceApiVersions as InstanceApiVersions, index$5_InstanceConfiguration as InstanceConfiguration, index$5_InstanceContact as InstanceContact, index$5_InstanceIcon as InstanceIcon, index$5_InstanceMediaAttachmentsConfiguration as InstanceMediaAttachmentsConfiguration, index$5_InstancePollsConfiguration as InstancePollsConfiguration, index$5_InstanceRegistrations as InstanceRegistrations, index$5_InstanceStatusesConfiguration as InstanceStatusesConfiguration, index$5_InstanceThumbnail as InstanceThumbnail, index$5_InstanceThumbnailVersions as InstanceThumbnailVersions, index$5_InstanceTranslationConfiguration as InstanceTranslationConfiguration, index$5_InstanceUrls as InstanceUrls, index$5_InstanceUsage as InstanceUsage, index$5_InstanceUsageUsers as InstanceUsageUsers, index$5_InstanceVapidConfiguration as InstanceVapidConfiguration, index$5_NotificationPolicy as NotificationPolicy, index$5_NotificationPolicyType as NotificationPolicyType, index$5_Search as Search };
}

type Direction = "next" | "prev";
interface Paginator<Entity, Params = undefined> extends PromiseLike<Entity> {
    /**
     * Get the current direction of the paginator.
     * @returns The current direction of the paginator.
     */
    getDirection(): Direction;
    /**
     * Creates a new paginator with the given direction.
     * @param direction New direction of the paginator.
     * @returns A new paginator with the given direction.
     */
    setDirection(direction: Direction): Paginator<Entity, Params>;
    /**
     * Clones the paginator.
     * @returns A new paginator with the same direction and parameters.
     */
    clone(): Paginator<Entity, Params>;
    next(params?: Params | string): Promise<IteratorResult<Entity, undefined>>;
    return(value: undefined | PromiseLike<undefined>): Promise<IteratorResult<Entity, undefined>>;
    throw(e?: unknown): Promise<IteratorResult<Entity, undefined>>;
    values(): AsyncIterableIterator<Entity>;
    [Symbol.asyncIterator](): AsyncIterator<Entity, undefined, Params | string | undefined>;
}

interface DefaultPaginationParams {
    /** Return results older than this ID. */
    readonly maxId?: string | null;
    /** Return results newer than this ID. */
    readonly sinceId?: string | null;
    /** Get a list of items with ID greater than this value excluding this ID */
    readonly minId?: string | null;
    /** Maximum number of results to return per page. Defaults to 40. NOTE: Pagination is done with the Link header from the response. */
    readonly limit?: number | null;
}

interface FetchAccountsParams {
    /** The IDs of the Accounts in the database. */
    readonly id: readonly string[];
}
interface CreateAccountParams {
    /** The desired username for the account */
    readonly username: string;
    /** The password to be used for login */
    readonly password: string;
    /** The email address to be used for login */
    readonly email: string;
    /** Whether the user agrees to the local rules, terms, and policies. These should be presented to the user in order to allow them to consent before setting this parameter to TRUE. */
    readonly agreement: boolean;
    /** The language of the confirmation email that will be sent */
    readonly locale: string;
    /** Text that will be reviewed by moderators if registrations require manual approval. */
    readonly reason?: string;
    /** https://github.com/mastodon/mastodon/pull/25342 */
    readonly timeZone?: string;
}
interface UpdateCredentialsParams {
    /** Whether the account should be shown in the profile directory. */
    readonly discoverable?: boolean;
    /** Whether the account has a bot flag. */
    readonly bot?: boolean;
    /** The display name to use for the profile. */
    readonly displayName?: string | null;
    /** The account bio. */
    readonly note?: string | null;
    /** Avatar image encoded using multipart/form-data */
    readonly avatar?: Blob | string | null;
    /** Header image encoded using multipart/form-data */
    readonly header?: Blob | string | null;
    /** Whether manual approval of follow requests is required. */
    readonly locked?: boolean | null;
    readonly source?: Partial<Pick<AccountSource, "privacy" | "sensitive" | "language">> | null;
    /** Whether you want to hide followers and followings on your profile  */
    readonly hideCollections?: boolean | null;
    /**
     * Profile metadata `name` and `value`.
     * (By default, max 4 fields and 255 characters per property/value)
     */
    readonly fieldsAttributes?: AccountField[] | null;
}
interface MuteAccountParams {
    /** Mute notifications in addition to statuses? Defaults to true. */
    readonly notifications?: boolean;
    /** Duration to mute in seconds. Defaults to 0 (indefinite). */
    readonly duration?: number;
}
interface CreateAccountNoteParams {
    readonly comment: string;
}
interface ListAccountStatusesParams extends DefaultPaginationParams {
    /** Only return statuses that have media attachments */
    readonly onlyMedia?: boolean | null;
    /** Only return statuses that have been pinned */
    readonly pinned?: boolean | null;
    /** Skip statuses that reply to other statuses */
    readonly excludeReplies?: boolean | null;
    /** Skip statuses that are boosts of other statuses */
    readonly excludeReblogs?: boolean | null;
    /** Only return statuses using a specific hashtag */
    readonly tagged?: string | null;
}
interface FollowAccountParams {
    /** Receive this account's reblogs in home timeline? Defaults to true */
    readonly reblogs?: boolean | null;
    /** Receive notifications when this account posts a status? Defaults to false */
    readonly notify?: boolean | null;
    /** Array of String (ISO 639-1 language two-letter code). Filter received statuses for these languages. If not provided, you will receive this account's posts in all languages */
    readonly languages?: string[] | null;
}
interface SearchAccountsParams {
    /** What to search for */
    readonly q: string;
    /** Maximum number of results. Defaults to 40. */
    readonly limit?: number | null;
    /** Attempt WebFinger lookup. Defaults to false. Use this when `q` is an exact address. */
    readonly resolve?: boolean | null;
    /** Only who the user is following. Defaults to false. */
    readonly following?: boolean | null;
    /** Skip the first n results. */
    readonly offset?: number | null;
}
interface LookupAccountParams {
    readonly acct: string;
}
interface FetchRelationshipsParams {
    /** Array of account IDs to check */
    readonly id: readonly string[];
    /** Whether relationships should be returned for suspended users, defaults to false. */
    readonly withSuspended?: boolean | null;
}
interface AccountRepository$1 {
    fetch(params: FetchAccountsParams, meta?: HttpMetaParams): Promise<Account$1[]>;
    $select(id: string): {
        /**
         * View information about a profile.
         * @return Account
         * @see https://docs.joinmastodon.org/methods/accounts/
         */
        fetch(meta?: HttpMetaParams): Promise<Account$1>;
        /**
         * Follow the given account.
         * @param id The id of the account in the database
         * @param params Parameters
         * @return Relationship
         * @see https://docs.joinmastodon.org/methods/accounts/
         */
        follow(params?: FollowAccountParams, meta?: HttpMetaParams<"json">): Promise<Relationship>;
        /**
         * Unfollow the given account
         * @param id The id of the account in the database
         * @return Relationship
         * @see https://docs.joinmastodon.org/methods/accounts/
         */
        unfollow(params?: FollowAccountParams, meta?: HttpMetaParams<"json">): Promise<Relationship>;
        /**
         * Block the given account. Clients should filter statuses from this account if received (e.g. due to a boost in the Home timeline)
         * @return Relationship
         * @see https://docs.joinmastodon.org/methods/accounts/
         */
        block(meta?: HttpMetaParams): Promise<Relationship>;
        /**
         * Unblock the given account.
         * @return Relationship
         * @see https://docs.joinmastodon.org/methods/accounts/
         */
        unblock(meta?: HttpMetaParams): Promise<Relationship>;
        /**
         * Add the given account to the user's featured profiles. (Featured profiles are currently shown on the user's own public profile.)
         * @return Relationship
         * @see https://docs.joinmastodon.org/methods/accounts#pin
         */
        pin(meta?: HttpMetaParams): Promise<Relationship>;
        /**
         * Remove the given account from the user's featured profiles.
         * @return Relationship
         * @see https://docs.joinmastodon.org/methods/accounts/
         */
        unpin(meta?: HttpMetaParams): Promise<Relationship>;
        /**
         * Mute the given account. Clients should filter statuses and notifications from this account, if received (e.g. due to a boost in the Home timeline).
         * @param params Parameter
         * @return Relationship
         * @see https://docs.joinmastodon.org/methods/accounts/
         */
        mute(params?: MuteAccountParams, meta?: HttpMetaParams<"json">): Promise<Relationship>;
        /**
         * Unmute the given account.
         * @return Relationship
         * @see https://docs.joinmastodon.org/methods/accounts/
         */
        unmute(meta?: HttpMetaParams): Promise<Relationship>;
        /**
         * @returns N/A
         */
        removeFromFollowers(meta?: HttpMetaParams): Promise<void>;
        featuredTags: {
            /**
             * Get featured tag of the account
             * @return FeaturedTags
             */
            list(meta?: HttpMetaParams): Paginator<FeaturedTag[]>;
        };
        note: {
            /**
             * Add personal note to the account
             * @param id ID of the account
             * @param param Parameters
             * @return Relationship
             */
            create(params: CreateAccountNoteParams, meta?: HttpMetaParams<"json">): Promise<Relationship>;
        };
        identityProofs: {
            /**
             * Identity proofs
             * @return Array of IdentityProof
             * @see https://github.com/tootsuite/mastodon/pull/10297
             */
            list(meta?: HttpMetaParams): Paginator<IdentityProof[]>;
        };
        lists: {
            /**
             * Fetch the list with the given ID. Used for verifying the title of a list.
             * @return Array of List
             * @see https://docs.joinmastodon.org/methods/timelines/lists/
             */
            list(meta?: HttpMetaParams): Paginator<List[]>;
        };
        followers: {
            /**
             * Accounts which follow the given account, if network is not hidden by the account owner.
             * @param params Parameters
             * @return Array of Account
             * @see https://docs.joinmastodon.org/methods/accounts/
             */
            list(params?: DefaultPaginationParams, meta?: HttpMetaParams): Paginator<Account$1[], DefaultPaginationParams>;
        };
        following: {
            /**
             * Accounts which the given account is following, if network is not hidden by the account owner.
             * @param params Parameters
             * @return Array of Account
             * @see https://docs.joinmastodon.org/methods/accounts/
             */
            list(params?: DefaultPaginationParams, meta?: HttpMetaParams): Paginator<Account$1[], DefaultPaginationParams>;
        };
        statuses: {
            /**
             * Statuses posted to the given account.
             * @param params Parameters
             * @return Array of Status
             * @see https://docs.joinmastodon.org/methods/accounts/
             */
            list(params?: ListAccountStatusesParams, meta?: HttpMetaParams): Paginator<Status[], ListAccountStatusesParams>;
        };
    };
    /**
     * This method allows to quickly convert a username of a known account to an ID that can be used with the REST API, or to check if a username is available for sign-up
     * @param params Parameters
     * @return Account
     */
    lookup(params: LookupAccountParams, meta?: HttpMetaParams): Promise<Account$1>;
    /**
     * Creates a user and account records. Returns an account access token
     * for the app that initiated the request. The app should save this token for later,
     * and should wait for the user to confirm their account by clicking a link in their email inbox.
     * @param params Parameters
     * @return Token
     * @see https://docs.joinmastodon.org/methods/accounts/#create
     */
    create(params: CreateAccountParams, meta?: HttpMetaParams<"multipart-form">): Promise<Token>;
    /**
     * Test to make sure that the user token works.
     * @return the user's own Account with Source
     * @see https://docs.joinmastodon.org/methods/accounts/
     */
    verifyCredentials(meta?: HttpMetaParams): Promise<AccountCredentials>;
    /**
     *  Update the user's display and preferences.
     * @param params Parameters
     * @return the user's own Account with Source
     * @see https://docs.joinmastodon.org/methods/accounts/
     */
    updateCredentials(params: UpdateCredentialsParams, meta?: HttpMetaParams<"multipart-form">): Promise<AccountCredentials>;
    relationships: {
        /**
         * Find out whether a given account is followed, blocked, muted, etc.
         * @return Array of Relationship
         * @see https://docs.joinmastodon.org/methods/accounts/
         */
        fetch(params: FetchRelationshipsParams, meta?: HttpMetaParams): Promise<Relationship[]>;
    };
    search: {
        /**
         * Search for matching accounts by username or display name.
         * @param params Parameters
         * @return Array of Account
         * @see https://docs.joinmastodon.org/methods/accounts/
         */
        list(params?: SearchAccountsParams, meta?: HttpMetaParams): Paginator<Account$1[], SearchAccountsParams>;
    };
    familiarFollowers: {
        /**
         * Obtain a list of all accounts that follow a given account, filtered for accounts you follow.
         * @returns Array of FamiliarFollowers
         */
        fetch(id: string[], meta?: HttpMetaParams): Promise<FamiliarFollowers[]>;
    };
}

interface ListAccountsParams extends DefaultPaginationParams {
    /** Filter for local accounts? */
    readonly local?: boolean | null;
    /** Filter for remote accounts? */
    readonly remote?: boolean | null;
    /** Filter by the given domain */
    readonly byDomain?: string | null;
    /** Filter for currently active accounts? */
    readonly active?: boolean | null;
    /** Filter for currently pending accounts? */
    readonly pending?: boolean | null;
    /** Filter for currently disabled accounts? */
    readonly disabled?: boolean | null;
    /** Filter for currently silenced accounts? */
    readonly silenced?: boolean | null;
    /** Filter for currently suspended accounts? */
    readonly suspended?: boolean | null;
    /** Boolean. Filter for accounts force-marked as sensitive? */
    readonly sensitized?: boolean | null;
    /** Username to search for */
    readonly username?: string | null;
    /** Display name to search for */
    readonly displayName?: string | null;
    /** Lookup a user with this email */
    readonly email?: string | null;
    /** Lookup users by this IP address */
    readonly ip?: string | null;
    /** Filter for staff accounts? */
    readonly staff?: boolean | null;
}
type AccountActionType = 'none' | 'disable' | 'silence' | 'sensitive' | 'suspend';
interface CreateActionParams {
    /** Type of action to be taken. Enumerable oneOf: `none` `disable` `silence` `suspend` */
    readonly type?: AccountActionType;
    /** ID of an associated report that caused this action to be taken */
    readonly reportId?: string;
    /** ID of a preset warning */
    readonly warningPresetId?: string | null;
    /** Additional text for clarification of why this action was taken */
    readonly text?: string | null;
    /** Whether an email should be sent to the user with the above information. */
    readonly sendEmailNotification?: boolean | null;
}
interface AccountRepository {
    /**
     * View accounts matching certain criteria for filtering, up to 100 at a time.
     * Pagination may be done with the HTTP Link header in the response.
     * @param params Parameters
     * @return Array of AdminAccount
     * @see https://docs.joinmastodon.org/methods/admin/
     */
    list(params?: ListAccountsParams, meta?: HttpMetaParams): Paginator<Account[], ListAccountsParams>;
    $select(id: string): {
        /**
         * View admin-level information about the given account.
         * @return AdminAccount
         * @see https://docs.joinmastodon.org/methods/admin/
         */
        fetch(meta?: HttpMetaParams): Promise<Account>;
        action: {
            /**
             * Perform an action against an account and log this action in the moderation history.
             * @param params Params
             * @return Account
             * @see https://docs.joinmastodon.org/methods/admin/accounts/#action
             */
            create(params: CreateActionParams, meta?: HttpMetaParams<"json">): Promise<void>;
        };
        /**
         * Approve the given local account if it is currently pending approval.
         * @return AdminAccount
         * @see https://docs.joinmastodon.org/methods/admin/
         */
        approve(meta?: HttpMetaParams): Promise<Account>;
        /**
         * Reject the given local account if it is currently pending approval.
         * @return AdminAccount
         * @see https://docs.joinmastodon.org/methods/admin/
         */
        reject(meta?: HttpMetaParams): Promise<Account>;
        /**
         * Re-enable a local account whose login is currently disabled.
         * @return AdminAccount
         * @see https://docs.joinmastodon.org/methods/admin/
         */
        enable(meta?: HttpMetaParams): Promise<Account>;
        /**
         * Unsilence a currently silenced account.
         * @return AdminAccount
         * @see https://docs.joinmastodon.org/methods/admin/
         */
        unsilence(meta?: HttpMetaParams): Promise<Account>;
        /**
         * Unsuspend a currently suspended account.
         * @return AdminAccount
         * @see https://docs.joinmastodon.org/methods/admin/
         */
        unsuspend(meta?: HttpMetaParams): Promise<Account>;
        /**
         * Unmark an account as sensitive
         * @return AdminAccount
         * @see https://docs.joinmastodon.org/methods/admin/accounts/#unsensitive
         */
        unsensitive(meta?: HttpMetaParams): Promise<Account>;
    };
}

interface TestCanonicalEmailBlockParams {
    /** The email to canonicalize and hash */
    readonly email: string;
}
interface CreateCanonicalEmailBlockParamsWithEmail {
    /** The email to canonicalize, hash, and block. If this parameter is provided, canonical_email_hash will be ignored. */
    readonly email: string;
}
interface CreateCanonicalEmailBlockParamsWithCanonicalEmailHash {
    /** The hash to test against. If email is not provided, this parameter is required. */
    readonly canonicalEmailHash: string;
}
type CreateCanonicalEmailBlockParams = CreateCanonicalEmailBlockParamsWithEmail | CreateCanonicalEmailBlockParamsWithCanonicalEmailHash;
interface CanonicalEmailBlockRepository {
    /**
     * List all canonical email blocks.
     * @param params Parameters
     * @return Array of CanonicalEmailBlock
     * @see https://docs.joinmastodon.org/methods/admin/canonical_email_blocks/
     */
    list(params?: DefaultPaginationParams, meta?: HttpMetaParams): Paginator<CanonicalEmailBlock[], DefaultPaginationParams>;
    /**
     * Canonicalize and hash an email address.
     * @param params Parameters
     * @return Array of CanonicalEmailBlock
     * @see https://docs.joinmastodon.org/methods/admin/canonical_email_blocks/#test
     */
    test(params: TestCanonicalEmailBlockParams, meta?: HttpMetaParams<"json">): Promise<CanonicalEmailBlock[]>;
    /**
     * Block a canonical email.
     * @param params Parameters
     * @return CanonicalEmailBlock
     * @see https://docs.joinmastodon.org/methods/admin/canonical_email_blocks
     */
    create(params: CreateCanonicalEmailBlockParams, meta?: HttpMetaParams<"json">): Promise<CanonicalEmailBlock>;
    $select(id: string): {
        /**
         * Show a single canonical email block
         * @return CanonicalEmailBlock
         * @see https://docs.joinmastodon.org/methods/admin/canonical_email_blocks
         */
        fetch(meta?: HttpMetaParams): Promise<CanonicalEmailBlock>;
        /**
         * Lift a block a canonical email.
         * @return null
         * @see https://docs.joinmastodon.org/methods/admin/canonical_email_blocks
         */
        remove(meta?: HttpMetaParams): Promise<void>;
    };
}

interface FetchDimensionParams {
    /**
     * Array of String. Request specific dimensions by their keystring. Supported dimensions include:
     *
     * - `languages` = Most-used languages on this server
     *
     * - `sources` = Most-used client apps on this server
     *
     * - `servers` = Remote servers with the most statuses
     *
     * - `space_usage` = How much space is used by your software stack
     *
     * - `software_versions` = The version numbers for your software stack
     *
     * - `tag_servers` = Most-common servers for statuses including a trending tag
     *
     * - `tag_languages` = Most-used languages for statuses including a trending tag
     *
     * - `instance_accounts` = Most-followed accounts from a remote server
     *
     * - `instance_languages` = Most-used languages from a remote server
     */
    readonly keys: readonly DimensionKey[];
    /** String (ISO 8601 Datetime). The start date for the time period. If a time is provided, it will be ignored. */
    readonly startAt?: string | null;
    /** String (ISO 8601 Datetime). The end date for the time period. If a time is provided, it will be ignored. */
    readonly endAt?: string | null;
    /** Integer. The maximum number of results to return for sources, servers, languages, tag or instance dimensions. */
    readonly limit?: string | null;
    readonly tagServers?: {
        /** String. When `tag_servers` is one of the requested keys, you must provide a trending tag ID to obtain information about which servers are posting the tag. */
        readonly id?: string | null;
    } | null;
    readonly tagLanguages?: {
        /** String. When `tag_languages` is one of the requested keys, you must provide a trending tag ID to obtain information about which languages are posting the tag. */
        readonly id?: string | null;
    } | null;
    readonly instanceAccounts?: {
        /** String. When `instance_accounts` is one of the requested keys, you must provide a domain to obtain information about popular accounts from that server. */
        readonly domain?: string | null;
    } | null;
    readonly instanceLanguages?: {
        /** String. When `instance_accounts` is one of the requested keys, you must provide a domain to obtain information about popular languages from that server. */
        readonly domain?: string | null;
    } | null;
}
interface DimensionRepository {
    /**
     * Obtain information about popularity of certain accounts, servers, languages, etc.
     * @see https://docs.joinmastodon.org/methods/admin/dimensions/#get
     */
    create(params: FetchDimensionParams, meta?: HttpMetaParams<"json">): Promise<Dimension[]>;
}

interface CreateDomainAllowParams {
    readonly domain: string;
}
interface DomainAllowRepository {
    /**
     * Show information about all allowed domains
     * @param params Parameters
     * @return Array of DomainAllow
     * @see https://docs.joinmastodon.org/methods/admin/domain_allows/#get
     */
    list(params?: DefaultPaginationParams, meta?: HttpMetaParams): Paginator<DomainAllow[], DefaultPaginationParams>;
    /**
     * Add a domain to the list of domains allowed to federate,
     * to be used when the instance is in allow-list federation mode.
     * @param params parameters
     * @return DomainAllow
     * @see https://docs.joinmastodon.org/methods/admin/domain_allows/#get-one
     */
    create(params: CreateDomainAllowParams, meta?: HttpMetaParams<"json">): Promise<DomainAllow>;
    $select(id: string): {
        /**
         * Show information about a single allowed domain
         * @return DomainAllow
         * @see https://docs.joinmastodon.org/methods/admin/domain_allows/#get-one
         */
        fetch(meta?: HttpMetaParams): Promise<DomainAllow>;
        /**
         * Delete a domain from the allowed domains list.
         * @return DomainAllow
         * @see https://docs.joinmastodon.org/methods/admin/
         */
        remove(meta?: HttpMetaParams): Promise<DomainAllow>;
    };
}

interface CreateDomainBlockParams$1 {
    /** The domain to block federation required*/
    readonly domain: string;
    /** Whether to apply a silence, suspend, or noop to the domain?*/
    readonly severity?: DomainBlockSeverity$1;
    /** Whether media attachments should be rejected*/
    readonly rejectMedia?: boolean;
    /** Whether reports from this domain should be rejected*/
    readonly rejectReports?: boolean;
    /**  A private note about this domain block, visible only to admins*/
    readonly privateComment?: string | null;
    /** A public note about this domain block, optionally shown on the about page*/
    readonly publicComment?: string | null;
    /** Whether to partially censor the domain when shown in public*/
    readonly obfuscate?: boolean;
}
interface ListDomainBlocksParams {
    readonly limit?: number;
}
type UpdateDomainBlockParams = Omit<CreateDomainBlockParams$1, "domain">;
interface DomainBlockRepository$1 {
    /**
     * Show information about all blocked domains
     * @param params Parameters
     * @return Array of DomainBlock
     * @see https://docs.joinmastodon.org/methods/admin/domain_blocks/#get
     */
    list(params?: ListDomainBlocksParams, meta?: HttpMetaParams): Paginator<DomainBlock$1[], ListDomainBlocksParams>;
    /**
     * Add a domain to the list of domains blocked from federating.
     * @param params Parameters
     * @return DomainBlock
     * @see https://docs.joinmastodon.org/methods/admin/domain_blocks/#post
     */
    create(params: CreateDomainBlockParams$1, meta?: HttpMetaParams<"json">): Promise<DomainBlock$1>;
    $select(id: string): {
        /**
         * Show information about a single blocked domain.
         * @return DomainBlock
         * @see https://docs.joinmastodon.org/methods/admin/domain_blocks/#get-one
         */
        fetch(meta?: HttpMetaParams): Promise<DomainBlock$1>;
        /**
         * Change parameters for an existing domain block.
         * @param params Parameters
         * @return DomainBlock
         * @see https://docs.joinmastodon.org/methods/admin/domain_blocks/#update
         */
        update(params?: UpdateDomainBlockParams, meta?: HttpMetaParams<"json">): Promise<DomainBlock$1>;
        /**
         * Lift a block against a domain.
         * @return DomainBlock
         * @see https://docs.joinmastodon.org/methods/admin/domain_blocks/#delete
         */
        remove(meta?: HttpMetaParams): Promise<void>;
    };
}

interface ListEmailDomainBlocksParams {
    /** Integer. Maximum number of results to return. Defaults to 100. */
    readonly limit?: number | null;
}
interface CreateEmailDomainBlockParams {
    /** The domain to block federation with. */
    readonly domain: string;
}
interface EmailDomainBlockRepository {
    /**
     * Show information about all email domains blocked from signing up.
     * @param params Parameters
     * @return Array of EmailDomainBlock
     * @see https://docs.joinmastodon.org/methods/admin/
     */
    list(params?: ListEmailDomainBlocksParams, meta?: HttpMetaParams): Paginator<EmailDomainBlock[], ListEmailDomainBlocksParams>;
    $select(id: string): {
        /**
         * Show information about a single email domain that is blocked from sign-ups.
         * @return EmailDomainBlock
         * @see https://docs.joinmastodon.org/methods/admin/
         */
        fetch(meta?: HttpMetaParams): Promise<EmailDomainBlock>;
        /**
         * Lift a block against an email domain.
         * @return null
         * @see https://docs.joinmastodon.org/methods/admin/
         */
        remove(meta?: HttpMetaParams): Promise<void>;
    };
    /**
     * Add a domain to the list of email domains blocked from sign-ups.
     * @param params Parameters
     * @return EmailDomainBlock
     * @see https://docs.joinmastodon.org/methods/admin/
     */
    create(params: CreateEmailDomainBlockParams, meta?: HttpMetaParams<"json">): Promise<EmailDomainBlock>;
}

interface ListIpBlocksParams {
    /** Integer. Maximum number of results to return. Defaults to 100. */
    readonly limit?: number | null;
}
interface CreateIpBlockParams {
    /** The IP address and prefix to block. */
    readonly ip?: string | null;
    /** The policy to apply to this IP range. */
    readonly severity: IpBlockSeverity;
    /** The reason for this IP block. */
    readonly comment?: string | null;
    /** The number of seconds in which this IP block will expire. */
    readonly expiresIn?: number | null;
}
interface UpdateIpBlockParams {
    /** The IP address and prefix to block. */
    readonly ip?: string | null;
    /** The policy to apply to this IP range. */
    readonly severity?: IpBlockSeverity | null;
    /** The reason for this IP block. */
    readonly comment?: string | null;
    /** The number of seconds in which this IP block will expire. */
    readonly expiresIn?: number | null;
}
interface IpBlockRepository {
    /**
     * Show information about all blocked IP ranges.
     * @param params Parameters
     * @return Array of IpBlock
     * @see https://docs.joinmastodon.org/methods/admin/ip_blocks/#get
     */
    list(params?: ListIpBlocksParams, meta?: HttpMetaParams): Paginator<IpBlock[], ListIpBlocksParams>;
    $select(id: string): {
        /**
         * Show information about a single IP block.
         * @return IpBlock
         * @see https://docs.joinmastodon.org/methods/admin/ip_blocks/#get-one
         */
        fetch(meta?: HttpMetaParams): Promise<IpBlock>;
        /**
         * Change parameters for an existing IP block.
         * @param params Parameters
         * @return IpBlock
         * @see https://docs.joinmastodon.org/methods/admin/ip_blocks/#update
         */
        update(params: UpdateIpBlockParams, meta?: HttpMetaParams<"json">): Promise<IpBlock>;
        /**
         * Lift a block against an IP range.
         * @return null
         * @see https://docs.joinmastodon.org/methods/admin/ip_blocks/#delete
         */
        remove(meta?: HttpMetaParams): Promise<void>;
    };
    /**
     * Add an IP address range to the list of IP blocks.
     * @param params Parameters
     * @return IpBlock
     * @see https://docs.joinmastodon.org/methods/admin/ip_blocks/#post
     */
    create(params: CreateIpBlockParams, meta?: HttpMetaParams<"json">): Promise<IpBlock>;
}

interface FetchMeasureParams {
    /**
     * Array of String. Request specific measures by their keystring. Supported measures include:
     *
     * `active_users` = Total active users on your instance within the time period
     *
     * `new_users` = Users who joined your instance within the time period
     *
     * `interactions` = Total interactions (favourites, boosts, replies) on local statuses within the time period
     *
     * `opened_reports` = Total reports filed within the time period
     *
     * `resolved_reports` = Total reports resolved within the time period
     *
     * `tag_accounts` = Total accounts who used a tag in at least one status within the time period
     *
     * `tag_uses` = Total statuses which used a tag within the time period
     *
     * `tag_servers` = Total remote origin servers for statuses which used a tag within the time period
     *
     * `instance_accounts` = Total accounts originating from a remote domain within the time period
     *
     * `instance_media_attachments` = Total space used by media attachments from a remote domain within the time period
     *
     * `instance_reports` = Total reports filed against accounts from a remote domain within the time period
     *
     * `instance_statuses` = Total statuses originating from a remote domain within the time period
     *
     * `instance_follows` = Total accounts from a remote domain followed by a local user within the time period
     *
     * `instance_followers` = Total local accounts followed by accounts from a remote domain within the time period
     */
    readonly keys: readonly MeasureKey[];
    /** String (ISO 8601 Datetime). The start date for the time period. If a time is provided, it will be ignored. */
    readonly startAt: string;
    /** String (ISO 8601 Datetime). The end date for the time period. If a time is provided, it will be ignored. */
    readonly endAt: string;
    readonly tagAccounts?: {
        /** String. When `tag_accounts` is one of the requested keys, you must provide a tag ID to obtain the measure of how many accounts used that hashtag in at least one status within the given time period. */
        readonly id?: string | null;
    } | null;
    readonly tagUses?: {
        /** String. When `tag_uses` is one of the requested keys, you must provide a tag ID to obtain the measure of how many statuses used that hashtag within the given time period. */
        readonly id?: string | null;
    } | null;
    readonly tagServers?: {
        /** String. When `tag_servers` is one of the requested keys, you must provide a tag ID to obtain the measure of how many servers used that hashtag in at least one status within the given time period. */
        readonly id?: string | null;
    } | null;
    readonly instanceAccounts?: {
        /** String. When `instance_accounts` is one of the requested keys, you must provide a remote domain to obtain the measure of how many accounts have been discovered from that server within the given time period. */
        readonly domain?: string | null;
    } | null;
    readonly instanceMediaAttachments?: {
        /** String. When `instance_media_attachments` is one of the requested keys, you must provide a remote domain to obtain the measure of how much space is used by media attachments from that server within the given time period. */
        readonly domain?: string | null;
    } | null;
    readonly instanceReports?: {
        /** String. When `instance_reports` is one of the requested keys, you must provide a remote domain to obtain the measure of how many reports have been filed against accounts from that server within the given time period. */
        readonly domain?: string | null;
    } | null;
    readonly instanceStatuses?: {
        /** String. When `instance_statuses` is one of the requested keys, you must provide a remote domain to obtain the measure of how many statuses originate from that server within the given time period. */
        readonly domain?: string | null;
    } | null;
    readonly instanceFollows?: {
        /** String. When `instance_follows` is one of the requested keys, you must provide a remote domain to obtain the measure of how many follows were performed on accounts from that server by local accounts within the given time period */
        readonly domain?: string | null;
    } | null;
    readonly instanceFollowers?: {
        /** String. When `instance_followers` is one of the requested keys, you must provide a remote domain to obtain the measure of how many follows were performed by accounts from that server on local accounts within the given time period. */
        readonly domain?: string | null;
    } | null;
}
interface MeasureRepository {
    /**
     * Obtain quantitative metrics about the server.
     * @see https://docs.joinmastodon.org/methods/admin/measures/#get
     */
    create(params: FetchMeasureParams, meta?: HttpMetaParams<"json">): Promise<Measure[]>;
}

interface ListReportsParams {
    readonly resolved?: boolean | null;
    readonly accountId?: string | null;
    readonly targetAccountId?: string | null;
    readonly byTargetDomain?: string | null;
}
interface ReportRepository$1 {
    /**
     * View all reports. Pagination may be done with HTTP Link header in the response.
     * @param params Parameters
     * @return Array of AdminReport
     * @see https://docs.joinmastodon.org/methods/admin/
     */
    list(params?: ListReportsParams, meta?: HttpMetaParams): Paginator<Report[], ListReportsParams>;
    $select(id: string): {
        /**
         * View information about the report with the given ID.
         * @return AdminReport
         * @see https://docs.joinmastodon.org/methods/admin/
         */
        fetch(meta?: HttpMetaParams): Promise<Report>;
        /**
         * Claim the handling of this report to yourself.
         * @return AdminReport
         * @see https://docs.joinmastodon.org/methods/admin/
         */
        assignToSelf(meta?: HttpMetaParams): Promise<Report>;
        /**
         * Unassign a report so that someone else can claim it.
         * @return AdminReport
         * @see https://docs.joinmastodon.org/methods/admin/
         */
        unassign(meta?: HttpMetaParams): Promise<Report>;
        /**
         * Mark a report as resolved with no further action taken.
         * @return AdminReport
         * @see https://docs.joinmastodon.org/methods/admin/
         */
        resolve(meta?: HttpMetaParams): Promise<Report>;
        /**
         * Reopen a currently closed report.
         * @return AdminReport
         * @see https://docs.joinmastodon.org/methods/admin/
         */
        reopen(meta?: HttpMetaParams): Promise<Report>;
    };
}

interface CreateRetentionParams {
    /** String (ISO 8601 Datetime). The start date for the time period. If a time is provided, it will be ignored. */
    readonly startAt: string;
    /** String (ISO 8601 Datetime). The end date for the time period. If a time is provided, it will be ignored. */
    readonly endAt: string;
    /** String (Enumerable oneOf). Specify whether to use `day` or `month` buckets. If any other value is provided, defaults to `day`. */
    readonly frequency: CohortFrequency;
}
interface RetentionRepository {
    /**
     * Generate a retention data report for a given time period and bucket.
     * @see https://docs.joinmastodon.org/methods/admin/retention/#create
     */
    create(params: CreateRetentionParams, meta?: HttpMetaParams<"json">): Promise<Cohort[]>;
}

interface TrendRepository$1 {
    links: {
        /**
         * Links that have been shared more than others, including unapproved and unreviewed links.
         * @see https://docs.joinmastodon.org/methods/admin/trends/#links
         */
        list(meta?: HttpMetaParams): Paginator<TrendLink[]>;
        /** https://github.com/mastodon/mastodon/pull/24257 */
        $select(id: string): {
            approve(meta?: HttpMetaParams): Promise<TrendLink>;
            reject(meta?: HttpMetaParams): Promise<TrendLink>;
        };
        /** https://github.com/mastodon/mastodon/pull/24257 */
        publishers: {
            list(meta?: HttpMetaParams): Paginator<TrendLink[]>;
            $select(id: string): {
                approve(meta?: HttpMetaParams): Promise<TrendLink>;
                reject(meta?: HttpMetaParams): Promise<TrendLink>;
            };
        };
    };
    statuses: {
        /**
         * Statuses that have been interacted with more than others, including unapproved and unreviewed statuses.
         * @see https://docs.joinmastodon.org/methods/admin/trends/#statuses
         */
        list(meta?: HttpMetaParams): Paginator<Status[]>;
        /** https://github.com/mastodon/mastodon/pull/24257 */
        $select(id: string): {
            approve(meta?: HttpMetaParams): Promise<Status>;
            reject(meta?: HttpMetaParams): Promise<Status>;
        };
    };
    tags: {
        /**
         * Tags that are being used more frequently within the past week, including unapproved and unreviewed tags.
         * @see https://docs.joinmastodon.org/methods/admin/trends/#tags
         */
        list(meta?: HttpMetaParams): Paginator<Tag[]>;
        /** https://github.com/mastodon/mastodon/pull/24257 */
        $select(id: string): {
            approve(meta?: HttpMetaParams): Promise<Tag>;
            reject(meta?: HttpMetaParams): Promise<Tag>;
        };
    };
}

interface AdminRepository {
    readonly accounts: AccountRepository;
    readonly canonicalEmailBlocks: CanonicalEmailBlockRepository;
    readonly dimensions: DimensionRepository;
    readonly domainAllows: DomainAllowRepository;
    readonly domainBlocks: DomainBlockRepository$1;
    readonly emailDomainBlocks: EmailDomainBlockRepository;
    readonly ipBlocks: IpBlockRepository;
    readonly measures: MeasureRepository;
    readonly reports: ReportRepository$1;
    readonly retention: RetentionRepository;
    readonly trends: TrendRepository$1;
}

interface AnnouncementRepository {
    /**
     * Fetch announcements
     * @return Announcements
     * @see https://docs.joinmastodon.org/methods/announcements/
     */
    list(meta?: HttpMetaParams): Paginator<Announcement[]>;
    $select(id: string): {
        /**
         * Dismiss announcement
         * @return Nothing
         * @see https://docs.joinmastodon.org/methods/announcements/
         */
        dismiss(meta?: HttpMetaParams): Promise<void>;
        /**
         * Add a reaction to an announcement
         * @param name Emoji string
         * @return N/A
         * @see https://docs.joinmastodon.org/methods/announcements/
         */
        addReaction(name: string, meta?: HttpMetaParams): Promise<void>;
        /**
         * Remove a reaction from an announcement
         * @param name Emoji string
         * @return N/A
         * @see https://docs.joinmastodon.org/methods/announcements/
         */
        removeReaction(name: string, meta?: HttpMetaParams): Promise<void>;
    };
}

interface CreateAppParams {
    /** A name of your application */
    readonly clientName: string;
    /**
     * Where the user should be redirected after authorization.
     * To display the authorization code to the user instead of redirecting to a web page,
     * use `urn:ietf:wg:oauth:2.0:oob` in this parameter.
     */
    readonly redirectUris: string;
    /** Space separated list of scopes. If none is provided, defaults to `read`. */
    readonly scopes: string;
    /** URL to the homepage of your app */
    readonly website?: string | null;
}
interface AppRepository {
    /**
     * Create a new application to obtain OAuth2 credentials.
     * @param params Parameters
     * @return Returns App with `client_id` and `client_secret`
     * @see https://docs.joinmastodon.org/methods/apps/
     */
    create(params: CreateAppParams, meta?: HttpMetaParams<"json">): Promise<Client$3>;
    /**
     * Confirm that the app's OAuth2 credentials work.
     * @return Application
     * @see https://docs.joinmastodon.org/methods/apps/
     */
    verifyCredentials(meta?: HttpMetaParams): Promise<Client$3>;
}

interface BlockRepository {
    /**
     * Blocked users
     * @param params Parameters
     * @return Array of Account
     * @see https://docs.joinmastodon.org/methods/accounts/blocks/
     */
    list(params?: DefaultPaginationParams, meta?: HttpMetaParams): Paginator<Account$1[], DefaultPaginationParams>;
}

interface BookmarkRepository {
    /**
     * Statuses the user has bookmarked.
     * @param params Parameters
     * @return Array of Statuses
     * @see https://docs.joinmastodon.org/methods/accounts/bookmarks/
     */
    list(params?: DefaultPaginationParams, meta?: HttpMetaParams): Paginator<Status[], DefaultPaginationParams>;
}

interface ConversationRepository {
    /**
     * Show conversation
     * @param params Parameters
     * @return Array of Conversation
     * @see https://docs.joinmastodon.org/methods/timelines/conversations/
     */
    list(params?: DefaultPaginationParams, meta?: HttpMetaParams): Paginator<Conversation[], DefaultPaginationParams>;
    $select(id: string): {
        /**
         * Remove conversation
         * @return N/A
         * @see https://docs.joinmastodon.org/methods/timelines/conversations/#delete
         */
        remove(meta?: HttpMetaParams): Promise<void>;
        /**
         * Mark as read
         * @return Conversation
         * @see https://docs.joinmastodon.org/methods/timelines/conversations/#post
         */
        read(meta?: HttpMetaParams): Promise<Conversation>;
        /** https://github.com/mastodon/mastodon/pull/25509 */
        unread(meta?: HttpMetaParams): Promise<Conversation>;
    };
}

interface CustomEmojiRepository {
    /**
     * Returns custom emojis that are available on the server.
     * @return Array of CustomEmoji
     * @see https://docs.joinmastodon.org/methods/instance/custom_emojis/
     */
    list(meta?: HttpMetaParams): Paginator<CustomEmoji[]>;
}

type DirectoryOrderType = "active" | "new";
interface ListDirectoryParams {
    /** How many accounts to load. Default 40. */
    readonly limit?: number | null;
    /** How many accounts to skip before returning results. Default 0. */
    readonly offset?: number | null;
    /** `active` to sort by most recently posted statuses (default) or `new` to sort by most recently created profiles. */
    readonly order?: DirectoryOrderType | null;
    /** Only return local accounts. */
    readonly local?: boolean | null;
}
interface DirectoryRepository {
    /**
     * List accounts visible in the directory.
     * @param params Parameters
     * @return Array of Account
     * @see https://docs.joinmastodon.org/methods/instance/directory/
     */
    list(params?: ListDirectoryParams, meta?: HttpMetaParams<"json">): Paginator<Account$1[], ListDirectoryParams>;
}

interface CreateDomainBlockParams {
    /** Domain to block */
    readonly domain: string;
}
interface RemoveDomainBlockParams {
    /** Domain to unblock */
    readonly domain: string;
}
interface DomainBlockRepository {
    /**
     * View domains the user has blocked.
     * @param params Parameters
     * @return Array of strings
     * @see https://docs.joinmastodon.org/methods/accounts/domain_blocks/
     */
    list(params?: DefaultPaginationParams, meta?: HttpMetaParams): Paginator<string[], DefaultPaginationParams>;
    /**
     * Block a domain to:
     * - hide all public posts from it
     * - hide all notifications from it
     * - remove all followers from it
     * - prevent following new users from it (but does not remove existing follows)
     * @param domain Domain to block.
     * @return N/A
     * @see https://docs.joinmastodon.org/methods/accounts/domain_blocks/
     */
    create(params: CreateDomainBlockParams, meta?: HttpMetaParams<"json">): Promise<void>;
    /**
     * Remove a domain block, if it exists in the user's array of blocked domains.
     * @param domain Domain to unblock
     * @return N/A
     * @see https://docs.joinmastodon.org/methods/accounts/domain_blocks/
     */
    remove(params: RemoveDomainBlockParams, meta?: HttpMetaParams<"json">): Promise<void>;
}

interface CreateConfirmationParams {
    /** If provided, updates the unconfirmed user’s email before resending the confirmation email. */
    readonly email?: string;
}
interface EmailRepository {
    confirmations: {
        /**
         * Resend confirmation email
         * @param params Form data parameters
         * @returns Empty object
         * @see https://docs.joinmastodon.org/methods/emails/#confirmation
         */
        create(params: CreateConfirmationParams, meta?: HttpMetaParams<"multipart-form">): Promise<void>;
    };
}

interface EndorsementRepository {
    /**
     * Accounts that the user is currently featuring on their profile.
     * @return Array of Account
     * @see https://docs.joinmastodon.org/methods/accounts/endorsements/
     */
    list(params?: DefaultPaginationParams, meta?: HttpMetaParams): Paginator<Account$1[], DefaultPaginationParams>;
}

interface FavouriteRepository {
    /**
     * Statuses the user has favourited.
     * @param params Parameters
     * @return Array of Status
     * @see https://docs.joinmastodon.org/methods/accounts/favourites/
     */
    list(params?: DefaultPaginationParams, meta?: HttpMetaParams): Paginator<Status[], DefaultPaginationParams>;
}

interface CreateFeaturedTagParams {
    /** The hashtag to be featured. */
    readonly name: string;
}
interface FeaturedTagRepository {
    /**
     * View your featured tags
     * @return Array of FeaturedTag
     * @see https://docs.joinmastodon.org/methods/accounts/featured_tags/
     * @done
     */
    list(meta?: HttpMetaParams): Paginator<FeaturedTag[]>;
    /**
     * Feature a tag
     * @param params Parameters
     * @return FeaturedTag
     * @see https://docs.joinmastodon.org/methods/accounts/featured_tags/
     */
    create(params: CreateFeaturedTagParams, meta?: HttpMetaParams<"multipart-form">): Promise<FeaturedTag>;
    suggestions: {
        /**
         * Shows your 10 most-used tags, with usage history for the past week.
         * @return Array of Tag with History
         * @see https://docs.joinmastodon.org/methods/accounts/featured_tags/
         */
        list(meta?: HttpMetaParams): Paginator<Tag$1[]>;
    };
    $select(id: string): {
        /**
         * Un-feature a tag
         * @return N/A
         * @see https://docs.joinmastodon.org/methods/accounts/featured_tags/
         */
        remove(meta?: HttpMetaParams): Promise<void>;
    };
}

interface CreateFilterParams$1 {
    /** Text to be filtered */
    readonly phrase: string;
    /**
     * Array of enumerable strings `home`, `notifications`, `public`, `thread`.
     * At least one context must be specified.
     */
    readonly context: readonly FilterContext[] | null;
    /** Should the server irreversibly drop matching entities from home and notifications? */
    readonly irreversible?: boolean | null;
    /** Consider word boundaries? */
    readonly wholeWord?: boolean | null;
    /** ISO 8601 Date-time for when the filter expires. Otherwise, null for a filter that doesn't expire. */
    readonly expiresIn?: number | null;
}
type UpdateFilterParams$1 = CreateFilterParams$1;
interface FilterRepository$1 {
    /**
     * View all filters
     * @return Filter
     * @see https://docs.joinmastodon.org/methods/accounts/filters/
     */
    list(meta?: HttpMetaParams): Paginator<Filter[]>;
    $select(id: string): {
        /**
         * View a single filter
         * @return Returns Filter
         * @see https://docs.joinmastodon.org/methods/accounts/filters/
         */
        fetch(meta?: HttpMetaParams): Promise<Filter>;
        /**
         * Update a filter
         * @param params Parameters
         * @return Filter
         * @see https://docs.joinmastodon.org/methods/accounts/filters/
         */
        update(params?: UpdateFilterParams$1, meta?: HttpMetaParams<"json">): Promise<Filter>;
        /**
         * Remove a filter
         * @return N/A
         * @see https://docs.joinmastodon.org/methods/accounts/filters/
         */
        remove(meta?: HttpMetaParams): Promise<void>;
    };
    /**
     * Create a filter
     * @param params Parameters
     * @return Filter
     * @see https://docs.joinmastodon.org/methods/accounts/filters/
     */
    create(params?: CreateFilterParams$1, meta?: HttpMetaParams<"json">): Promise<Filter>;
}

interface FollowRequestRepository {
    /**
     * Pending Follows
     * @param params Parameters
     * @return Array of Account
     * @see https://docs.joinmastodon.org/methods/accounts/follow_requests/
     */
    list(params?: DefaultPaginationParams, meta?: HttpMetaParams): Paginator<Account$1[], DefaultPaginationParams>;
    $select(id: string): {
        /**
         * Accept Follow
         * @return Relationship
         * @see https://docs.joinmastodon.org/methods/accounts/follow_requests/#post-authorize
         */
        authorize(meta?: HttpMetaParams): Promise<Relationship>;
        /**
         * Reject Follow
         * @return Relationship
         * @see https://docs.joinmastodon.org/methods/accounts/follow_requests/#post-reject
         */
        reject(meta?: HttpMetaParams): Promise<Relationship>;
    };
}

interface FollowedTagRepository {
    list(params?: DefaultPaginationParams, meta?: HttpMetaParams): Paginator<Tag$1[], DefaultPaginationParams>;
}

interface InstanceRepository$1 {
    /**
     * Information about the server.
     * @return Instance
     * @see https://docs.joinmastodon.org/methods/instance/
     */
    fetch(meta?: HttpMetaParams): Promise<Instance$1>;
    peers: {
        /**
         * Domains that this instance is aware of.
         * @return Array of Activity
         * @see https://docs.joinmastodon.org/methods/instance/
         */
        list(meta?: HttpMetaParams): Paginator<string[]>;
    };
    activity: {
        /**
         * Instance activity over the last 3 months, binned weekly.
         * @return Array of Activity
         * @see https://docs.joinmastodon.org/methods/instance/#activity
         */
        list(meta?: HttpMetaParams): Paginator<Activity[]>;
    };
    languages: {
        /** https://github.com/mastodon/mastodon/pull/24443 */
        list(meta?: HttpMetaParams): Promise<string[]>;
    };
    extendedDescription: {
        /**
         * Obtain an extended description of this server
         */
        fetch(meta?: HttpMetaParams): Promise<ExtendedDescription>;
    };
    translationLanguages: {
        /** https://github.com/mastodon/mastodon/pull/24037 */
        list(meta?: HttpMetaParams): Promise<Record<string, string[]>>;
    };
    domainBlocks: {
        /**
         * Obtain a list of domains that have been blocked.
         * @see https://docs.joinmastodon.org/methods/instance/#domain_blocks
         */
        fetch(meta?: HttpMetaParams): Promise<DomainBlock[]>;
    };
}

interface CreateListParams {
    /** The title of the list to be created. */
    readonly title: string;
    /** https://github.com/mastodon/mastodon/pull/22048/files */
    readonly exclusive?: boolean;
}
type UpdateListParams = CreateListParams;
interface AddListAccountsParams {
    /** Array of account IDs */
    readonly accountIds: readonly string[];
}
type RemoveListAccountsParams = AddListAccountsParams;
interface ListRepository {
    $select(id: string): {
        /**
         * Fetch the list with the given ID. Used for verifying the title of a list.
         * @return List
         * @see https://docs.joinmastodon.org/methods/timelines/lists/
         */
        fetch(meta?: HttpMetaParams): Promise<List>;
        /**
         * Change the title of a list.
         * @param params Parameters
         * @return List
         * @see https://docs.joinmastodon.org/methods/timelines/lists/
         */
        update(params: UpdateListParams, meta?: HttpMetaParams<"json">): Promise<List>;
        /**
         * Delete a list
         * @param id ID of the list in the database
         * @return N/A
         * @see https://docs.joinmastodon.org/methods/timelines/lists/
         */
        remove(meta?: HttpMetaParams): Promise<void>;
        accounts: {
            /**
             * View accounts in list
             * @param id ID of the list in the database
             * @param params Parameters
             * @return Array of Account
             * @see https://docs.joinmastodon.org/methods/timelines/lists#accounts
             */
            list(params?: DefaultPaginationParams, meta?: HttpMetaParams): Paginator<Account$1[], DefaultPaginationParams>;
            /**
             * Add accounts to the given list. Note that the user must be following these accounts.
             * @param id ID of the list in the database
             * @param params Parameters
             * @return N/A
             * @see https://docs.joinmastodon.org/methods/timelines/lists#accounts-add
             */
            create(params: AddListAccountsParams, meta?: HttpMetaParams<"json">): Promise<void>;
            /**
             * Remove accounts from the given list.
             * @param id ID of the list in the database
             * @param params Parameters
             * @return N/A
             * @see https://docs.joinmastodon.org/methods/timelines/lists#accounts-remove
             */
            remove(params: RemoveListAccountsParams, meta?: HttpMetaParams<"json">): Promise<void>;
        };
    };
    /**
     * Fetch all lists that the user owns.
     * @return Array of List
     * @see https://docs.joinmastodon.org/methods/timelines/lists/
     */
    list(meta?: HttpMetaParams): Paginator<List[]>;
    /**
     * Create a new list.
     * @param params Parameters
     * @return List
     * @see https://docs.joinmastodon.org/methods/timelines/lists/
     */
    create(params: CreateListParams, meta?: HttpMetaParams<"json">): Promise<List>;
}

interface FetchMarkersParams {
    /**
     * Array of markers to fetch.
     * String enum anyOf `home`, `notifications`.
     * If not provided, an empty object will be returned.
     */
    readonly timeline?: readonly MarkerTimeline[];
}
type CreateMarkersParams = {
    /** ID of the last status read in the timeline. */
    readonly [key in MarkerTimeline]?: Pick<MarkerItem, "lastReadId">;
};
interface MarkerRepository {
    /**
     * Get saved timeline position
     * @param params Parameters
     * @return Markers
     * @see https://docs.joinmastodon.org/methods/timelines/markers/
     */
    fetch(params?: FetchMarkersParams, meta?: HttpMetaParams): Promise<Marker>;
    /**
     * Save position in timeline
     * @param params Parameters
     * @return Markers
     * @see https://github.com/tootsuite/mastodon/pull/11762
     */
    create(params: CreateMarkersParams, meta?: HttpMetaParams<"json">): Promise<Marker>;
}

interface CreateMediaAttachmentParams$1 {
    /** The file to be attached, using multipart form data. */
    readonly file: Blob | string;
    /** A plain-text description of the media, for accessibility purposes. */
    readonly description?: string | null;
    /** Two floating points (x,y), comma-delimited, ranging from -1.0 to 1.0 */
    readonly focus?: string | null;
    /** Custom thumbnail */
    readonly thumbnail?: Blob | string | null;
}
type UpdateMediaAttachmentParams = Partial<CreateMediaAttachmentParams$1>;
interface MediaAttachmentRepository$1 {
    /**
     * Creates an attachment to be used with a new status.
     * @param params Parameters
     * @return Attachment
     * @see https://docs.joinmastodon.org/methods/statuses/media/
     */
    create(params: CreateMediaAttachmentParams$1, meta?: HttpMetaParams<"json">): Promise<MediaAttachment>;
    $select(id: string): {
        /**
         * Fetches an attachment to be used with a new status.
         * @param id ID of the attachment
         * @see https://github.com/tootsuite/mastodon/pull/13210
         */
        fetch(meta?: HttpMetaParams): Promise<MediaAttachment>;
        /**
         * Update an Attachment, before it is attached to a status and posted.
         * @param id The id of the Attachment entity to be updated
         * @param params Parameters
         * @return Attachment
         * @see https://docs.joinmastodon.org/methods/statuses/media/
         */
        update(params: UpdateMediaAttachmentParams, meta?: HttpMetaParams<"json">): Promise<MediaAttachment>;
    };
}

interface MuteRepository {
    /**
     * Accounts the user has muted.
     * @param params Parameters
     * @return Array of Account
     * @see https://docs.joinmastodon.org/methods/accounts/mutes/
     */
    list(params?: DefaultPaginationParams, meta?: HttpMetaParams<"json">): Paginator<Account$1[], DefaultPaginationParams>;
}

interface ListNotificationsParams$1 extends DefaultPaginationParams {
    /** Instead of specifying every known type to exclude, you can specify only the types you want. */
    readonly types?: readonly NotificationType[] | null;
    /** ID of the account */
    readonly accountId?: string | null;
    /** Array of notifications to exclude (Allowed values: "follow", "favourite", "reblog", "mention") */
    readonly excludeTypes?: readonly NotificationType[] | null;
}
interface FetchUnreadCountParams$1 {
    /** Maximum number of results to return. Defaults to 100 notifications. Max 1000 notifications. */
    limit?: number | null;
    /** Types of notifications that should count towards unread notifications. */
    types?: readonly NotificationType[] | null;
    /** Types of notifications that should not count towards unread notifications. */
    excludeTypes?: readonly NotificationType[] | null;
    /** Only count unread notifications received from the specified account. */
    accountId?: string | null;
}
interface NotificationRepository$1 {
    /**
     * Notifications concerning the user.
     * This API returns Link headers containing links to the next/previous page.
     * However, the links can also be constructed dynamically using query params and `id` values.
     * @param params Query parameter
     * @return Array of Notification
     * @see https://docs.joinmastodon.org/methods/notifications/
     */
    list(params?: ListNotificationsParams$1, meta?: HttpMetaParams<"json">): Paginator<Notification[], ListNotificationsParams$1>;
    /**
     * Notifications concerning the user.
     * This API returns Link headers containing links to the next/previous page.
     * However, the links can also be constructed dynamically using query params and `id` values.
     * @param params Query parameter
     * @return Array of Notification
     * @see https://docs.joinmastodon.org/methods/notifications/
     */
    fetch(params?: ListNotificationsParams$1, meta?: HttpMetaParams): Promise<Notification[]>;
    $select(id: string): {
        /**
         * View information about a notification with a given ID.
         * @return Notification
         * @see https://docs.joinmastodon.org/methods/notifications/
         */
        fetch(meta?: HttpMetaParams): Promise<Notification>;
        /**
         * Clear a single notification from the server.
         * @return N/A
         * @see https://docs.joinmastodon.org/methods/notifications/
         */
        dismiss(meta?: HttpMetaParams): Promise<void>;
    };
    /**
     * Clear all notifications from the server.
     * @return N/A
     * @see https://docs.joinmastodon.org/methods/notifications/
     */
    clear(meta?: HttpMetaParams): Promise<void>;
    requests: {
        /**
         * Notification requests for notifications filtered by the user’s policy. This API returns Link headers containing links to the next/previous page.
         */
        list(params?: DefaultPaginationParams, meta?: HttpMetaParams<"json">): Paginator<NotificationRequest[], DefaultPaginationParams>;
        $select(id: string): {
            /**
             * View information about a notification request with a given ID.
             */
            fetch(meta?: HttpMetaParams): Promise<NotificationRequest>;
            /**
             * Accept a notification request, which merges the filtered notifications from that user back into the main notification and accepts any future notification from them.
             */
            accept(meta?: HttpMetaParams): Promise<void>;
            /**
             * Dismiss a notification request, which hides it and prevent it from contributing to the pending notification requests count.
             */
            dismiss(meta?: HttpMetaParams): Promise<void>;
        };
        /**
         * Accepts multiple notification requests, which merges the filtered notifications from those users back into the main notifications and accepts any future notification from them.
         */
        accept(meta?: HttpMetaParams): Promise<void>;
        /**
         * Dismiss multiple notification requests, which hides them and prevent them from contributing to the pending notification requests count.
         */
        dismiss(meta?: HttpMetaParams): Promise<void>;
        merged: {
            /**
             * Check whether accepted notification requests have been merged. Accepting notification requests schedules a background job to merge the filtered notifications back into the normal notification list. When that process has finished, the client should refresh the notifications list at its earliest convenience. This is communicated by the notifications_merged streaming event but can also be polled using this endpoint.
             */
            fetch(meta?: HttpMetaParams): Promise<{
                merged: boolean;
            }>;
        };
    };
    unreadCount: {
        /**
         * Get the (capped) number of unread notification groups for the current user. A notification is
         * considered unread if it is more recent than the notifications read marker. Because the count
         * is dependant on the parameters, it is computed every time and is thus a relatively slow
         * operation (although faster than getting the full corresponding notifications), therefore the
         * number of returned notifications is capped.
         */
        fetch(params?: FetchUnreadCountParams$1, meta?: HttpMetaParams): Promise<{
            count: number;
        }>;
    };
}

interface VotePollParams {
    /** Array of own votes containing index for each option (starting from 0) */
    readonly choices: readonly number[];
}
interface PollRepository {
    $select(id: string): {
        /**
         * View a poll
         * @return Poll
         * @see https://docs.joinmastodon.org/methods/statuses/polls#get
         */
        fetch(meta?: HttpMetaParams): Promise<Poll>;
        votes: {
            /**
             * Vote on a poll
             * @param params Parameters
             * @return Poll
             * @see https://docs.joinmastodon.org/methods/statuses/polls#vote
             */
            create(params: VotePollParams, meta?: HttpMetaParams<"json">): Promise<Poll>;
        };
    };
}

interface PreferenceRepository {
    /**
     * Preferences defined by the user in their account settings.
     * @return Preferences by key and value
     * @see https://docs.joinmastodon.org/methods/accounts/preferences/
     */
    fetch(meta?: HttpMetaParams): Promise<Preference>;
}

interface CreateWebPushSubscriptionParams {
    readonly subscription: {
        /** Endpoint URL that is called when a notification event occurs. */
        readonly endpoint: string;
        readonly keys: {
            /** User agent public key. Base64 encoded string of public key of ECDH key using `prime256v1` curve. */
            readonly p256dh: string;
            /** Auth secret. Base64 encoded string of 16 bytes of random data. */
            readonly auth: string;
        };
    };
    readonly data?: {
        readonly alerts?: Partial<WebPushSubscriptionAlerts> | null;
    } | null;
    readonly policy: WebPushSubscriptionPolicy;
}
type UpdateWebPushSubscriptionParams = Pick<CreateWebPushSubscriptionParams, "data">;
interface WebPushSubscriptionRepository {
    /**
     * Add a Web Push API subscription to receive notifications.
     * Each access token can have one push subscription.
     * If you create a new subscription, the old subscription is deleted.
     * @param params Parameters
     * @return Returns Push Subscription
     * @see https://docs.joinmastodon.org/methods/push
     */
    create(params: CreateWebPushSubscriptionParams, meta?: HttpMetaParams<"json">): Promise<WebPushSubscription>;
    /**
     * View the PushSubscription currently associated with this access token.
     * @return PushSubscription
     * @see https://docs.joinmastodon.org/methods/push/#get
     */
    fetch(meta?: HttpMetaParams): Promise<WebPushSubscription>;
    /**
     * Updates the current push subscription. Only the data part can be updated. To change fundamentals, a new subscription must be created instead.
     * @param params Parameters
     * @return PushSubscription
     * @see https://docs.joinmastodon.org/methods/push/#update
     */
    update(params: UpdateWebPushSubscriptionParams, meta?: HttpMetaParams<"json">): Promise<WebPushSubscription>;
    /**
     * Removes the current Web Push API subscription.
     * @return N/A
     * @see https://docs.joinmastodon.org/methods/push/#delete
     */
    remove(meta?: HttpMetaParams): Promise<void>;
}

interface PushRepository {
    readonly subscription: WebPushSubscriptionRepository;
}

interface ReportAccountParams {
    /** ID of the account to report */
    readonly accountId: string;
    /** Array of Statuses to attach to the report, for context */
    readonly statusIds?: readonly string[] | null;
    /** Reason for the report (default max 1000 characters) */
    readonly comment?: string | null;
    /** If the account is remote, should the report be forwarded to the remote admin? */
    readonly forward?: boolean | null;
    /** category can be one of: spam, violation, other (default) */
    readonly category?: ReportCategory | null;
    /** must reference rules returned in GET /api/v1/instance */
    readonly ruleIds?: readonly string[] | null;
    /** https://github.com/mastodon/mastodon/pull/25866 */
    readonly forwardToDomains?: readonly string[] | null;
}
interface ReportRepository {
    /**
     * File a report
     * @param params Parameters
     * @return Report
     * @see https://docs.joinmastodon.org/methods/accounts/reports/
     */
    create(params: ReportAccountParams, meta?: HttpMetaParams<"json">): Promise<Report$1>;
}

interface UpdateScheduledStatusParams {
    /** ISO 8601 Date-time at which the status will be published. Must be at least 5 minutes into the future. */
    readonly scheduledAt: string;
}
interface ScheduledStatusRepository {
    /**
     * View scheduled statuses
     * @param params Parameters
     * @return Array of ScheduledStatus
     * @see https://docs.joinmastodon.org/methods/statuses/scheduled_statuses/
     */
    list(params?: DefaultPaginationParams, meta?: HttpMetaParams): Paginator<ScheduledStatus[], DefaultPaginationParams>;
    $select(id: string): {
        /**
         * View a single scheduled status
         * @return ScheduledStatus
         * @see https://docs.joinmastodon.org/methods/statuses/scheduled_statuses/
         */
        fetch(meta?: HttpMetaParams): Promise<ScheduledStatus>;
        /**
         * Update Scheduled status
         * @param params Parameters
         * @return ScheduledStatus
         * @see https://docs.joinmastodon.org/api/rest/scheduled-statuses/#put-api-v1-scheduled-statuses-id
         */
        update(params: UpdateScheduledStatusParams, meta?: HttpMetaParams<"json">): Promise<ScheduledStatus>;
        /**
         * Cancel a scheduled status
         * @return N/A
         * @see https://docs.joinmastodon.org/methods/statuses/scheduled_statuses/
         */
        remove(meta?: HttpMetaParams): Promise<void>;
    };
}

type SearchType$1 = "accounts" | "hashtags" | "statuses";
interface SearchParams$1 extends DefaultPaginationParams {
    /** Attempt WebFinger lookup. Defaults to false. */
    readonly q: string;
    /** Enum(accounts, hashtags, statuses) */
    readonly type?: SearchType$1 | null;
    /** Attempt WebFinger look-up */
    readonly resolve?: boolean | null;
    /** If provided, statuses returned will be authored only by this account */
    readonly accountId?: string | null;
}
interface SearchRepository$1 {
    /**
     * @deprecated Use `list` instead
     */
    fetch(params: SearchParams$1, meta?: HttpMetaParams): Search$1;
    /**
     * Search, but hashtags is an array of strings instead of an array of Tag.
     * @param params Parameters
     * @return Results
     * @see https://docs.joinmastodon.org/methods/search/
     */
    list(params: SearchParams$1, meta?: HttpMetaParams): Paginator<Search$1, SearchParams$1>;
}

interface FetchStatusesParams {
    /** The IDs of the Statuses in the database. */
    readonly id: readonly string[];
}
interface CreateStatusParamsBase {
    /** ID of the status being replied to, if status is a reply */
    readonly inReplyToId?: string | null;
    /** Mark status and attached media as sensitive? */
    readonly sensitive?: boolean | null;
    /** Text to be shown as a warning or subject before the actual content. Statuses are generally collapsed behind this field. */
    readonly spoilerText?: string | null;
    /** Visibility of the posted status. Enumerable oneOf public, unlisted, private, direct. */
    readonly visibility?: StatusVisibility | null;
    /** ISO 639 language code for this status. */
    readonly language?: string | null;
    /** https://github.com/mastodon/mastodon/pull/18350 */
    readonly allowedMentions?: readonly string[] | null;
}
interface CreateStatusPollParam {
    /** Array of possible answers. If provided, `media_ids` cannot be used, and `poll[expires_in]` must be provided. */
    readonly options: readonly string[];
    /** Duration the poll should be open, in seconds. If provided, media_ids cannot be used, and poll[options] must be provided. */
    readonly expiresIn: number;
    /** Allow multiple choices? */
    readonly multiple?: boolean | null;
    /** Hide vote counts until the poll ends? */
    readonly hideTotals?: boolean | null;
}
interface CreateStatusParamsWithStatus extends CreateStatusParamsBase {
    /** Text content of the status. If `media_ids` is provided, this becomes optional. Attaching a `poll` is optional while `status` is provided. */
    readonly status: string;
    /** Array of Attachment ids to be attached as media. If provided, `status` becomes optional, and `poll` cannot be used. */
    readonly mediaIds?: never;
    readonly poll?: CreateStatusPollParam | null;
}
interface CreateStatusParamsWithMediaIds extends CreateStatusParamsBase {
    /** Array of Attachment ids to be attached as media. If provided, `status` becomes optional, and `poll` cannot be used. */
    readonly mediaIds: readonly string[];
    /** Text content of the status. If `media_ids` is provided, this becomes optional. Attaching a `poll` is optional while `status` is provided. */
    readonly status?: string | null;
    readonly poll?: never;
}
type CreateStatusParams = CreateStatusParamsWithStatus | CreateStatusParamsWithMediaIds;
type CreateScheduledStatusParams = CreateStatusParams & {
    /** ISO 8601 Date-time at which to schedule a status. Providing this parameter will cause ScheduledStatus to be returned instead of Status. Must be at least 5 minutes in the future. */
    readonly scheduledAt?: string | null;
};
interface UpdateStatusMediaAttribute {
    /** The ID of the media attachment to be modified */
    readonly id: string;
    /** A plain-text description of the media, for accessibility purposes. */
    readonly description?: string | null;
    /** Two floating points (x,y), comma-delimited, ranging from -1.0 to 1.0 */
    readonly focus?: string | null;
    /** Custom thumbnail */
    readonly thumbnail?: Blob | string | null;
}
type UpdateStatusParams = CreateStatusParams & {
    /** https://github.com/mastodon/mastodon/pull/20878 */
    readonly mediaAttributes?: readonly UpdateStatusMediaAttribute[];
};
interface ReblogStatusParams {
    /** any visibility except limited or direct (i.e. public, unlisted, private). Defaults to public. Currently unused in UI. */
    readonly visibility: StatusVisibility;
}
interface TranslateStatusParams {
    /** String (ISO 639 language code). The status content will be translated into this language. Defaults to the user’s current locale. */
    readonly lang?: string;
}
interface StatusRepository {
    /**
     * Obtain information about multiple statuses.
     */
    fetch(params: FetchStatusesParams, meta?: HttpMetaParams): Promise<Status[]>;
    /**
     * Post a new status.
     * @param params Parameters
     * @return Status. When scheduled_at is present, ScheduledStatus is returned instead.
     * @see https://docs.joinmastodon.org/api/rest/statuses/#post-api-v1-statuses
     */
    create(params: CreateStatusParams, meta?: HttpMetaParams<"json">): Promise<Status>;
    create(params: CreateScheduledStatusParams, meta?: HttpMetaParams<"json">): Promise<ScheduledStatus>;
    $select(id: string): {
        /**
         * View information about a status.
         * @return Status
         * @see https://docs.joinmastodon.org/methods/statuses/
         */
        fetch(meta?: HttpMetaParams): Promise<Status>;
        /**
         * Update a status
         * @param params Parameters
         * @return Status. When scheduled_at is present, ScheduledStatus is returned instead.
         * @see https://docs.joinmastodon.org/api/rest/statuses/#post-api-v1-statuses
         */
        update(params: UpdateStatusParams, meta?: HttpMetaParams<"json">): Promise<Status>;
        /**
         * Delete one of your own statuses.
         * @return Status with source text and `media_attachments` or `poll`
         * @see https://docs.joinmastodon.org/methods/statuses/
         */
        remove(meta?: HttpMetaParams): Promise<Status>;
        context: {
            /**
             * View statuses above and below this status in the thread.
             * @return Context
             * @see https://docs.joinmastodon.org/methods/statuses/
             */
            fetch(meta?: HttpMetaParams): Promise<Context>;
        };
        card: {
            /**
             * Preview card
             * @return Card
             * @see https://docs.joinmastodon.org/api/rest/statuses/#get-api-v1-statuses-id-card
             * @deprecated
             */
            fetch(meta?: HttpMetaParams): Promise<PreviewCard>;
        };
        /**
         * Add a status to your favourites list.
         * @return Status
         * @see https://docs.joinmastodon.org/methods/statuses/
         */
        favourite(meta?: HttpMetaParams): Promise<Status>;
        /**
         * Remove a status from your favourites list.
         * @return Status
         * @see https://docs.joinmastodon.org/methods/statuses/
         */
        unfavourite(meta?: HttpMetaParams): Promise<Status>;
        /**
         * Do not receive notifications for the thread that this status is part of. Must be a thread in which you are a participant.
         * @return Status
         * @see https://docs.joinmastodon.org/methods/statuses/
         */
        mute(meta?: HttpMetaParams): Promise<Status>;
        /**
         * Start receiving notifications again for the thread that this status is part of.
         * @return Status
         * @see https://docs.joinmastodon.org/methods/statuses/
         */
        unmute(meta?: HttpMetaParams): Promise<Status>;
        rebloggedBy: {
            /**
             * View who boosted a given status.
             * @return Array of Account
             * @see https://docs.joinmastodon.org/methods/statuses/
             */
            list(meta?: HttpMetaParams): Paginator<Account$1[]>;
        };
        favouritedBy: {
            /**
             * View who favourited a given status.
             * @return Array of Account
             * @see https://docs.joinmastodon.org/methods/statuses/
             */
            list(meta?: HttpMetaParams): Paginator<Account$1[]>;
        };
        /**
         * Re-share a status.
         * @return Status
         * @see https://docs.joinmastodon.org/api/rest/statuses/#post-api-v1-statuses-id-reblog
         */
        reblog(params?: ReblogStatusParams, meta?: HttpMetaParams<"json">): Promise<Status>;
        /**
         * Undo a re-share of a status.
         * @return Status
         * @see https://docs.joinmastodon.org/methods/statuses/
         */
        unreblog(meta?: HttpMetaParams): Promise<Status>;
        /**
         * Feature one of your own public statuses at the top of your profile.
         * @return Status
         * @see https://docs.joinmastodon.org/methods/statuses/
         */
        pin(meta?: HttpMetaParams): Promise<Status>;
        /**
         * Un-feature a status from the top of your profile.
         * @return Status
         * @see https://docs.joinmastodon.org/methods/statuses/
         */
        unpin(meta?: HttpMetaParams): Promise<Status>;
        /**
         * Privately bookmark a status.
         * @return Status
         * @see https://docs.joinmastodon.org/methods/statuses/
         */
        bookmark(meta?: HttpMetaParams): Promise<Status>;
        /**
         * Remove a status from your private bookmarks.
         * @return Status
         * @see https://docs.joinmastodon.org/methods/statuses/
         */
        unbookmark(meta?: HttpMetaParams): Promise<Status>;
        history: {
            /**
             * Get all known versions of a status, including the initial and current states.
             * @returns StatusEdit
             * @see https://docs.joinmastodon.org/methods/statuses/#history
             */
            list(meta?: HttpMetaParams): Paginator<StatusEdit[]>;
        };
        source: {
            /**
             * Obtain the source properties for a status so that it can be edited.
             * @returns StatusSource
             * @see https://docs.joinmastodon.org/methods/statuses/#source
             */
            fetch(meta?: HttpMetaParams): Promise<StatusSource>;
        };
        /**
         * Translate the status content into some language.
         * @param params Form data parameters
         * @returns Translation
         */
        translate(params: TranslateStatusParams, meta?: HttpMetaParams): Promise<Translation>;
    };
}

interface ListSuggestionParams {
    /** Integer. Maximum number of results to return. Defaults to 40. */
    readonly limit?: number | null;
}
interface SuggestionRepository$1 {
    /**
     * Accounts the user has had past positive interactions with, but is not yet following.
     * @param params Parameters
     * @return Array of Accounts
     * @see https://docs.joinmastodon.org/methods/suggestions/#v1
     */
    list(params?: ListSuggestionParams, meta?: HttpMetaParams): Paginator<Account$1[], ListSuggestionParams>;
    $select(id: string): {
        /**
         * Remove an account from follow suggestions.
         * @return N/A
         * @see https://docs.joinmastodon.org/methods/accounts/suggestions/
         */
        remove(id: string, meta?: HttpMetaParams): Promise<void>;
    };
}

interface TagRepository {
    $select(id: string): {
        /**
         * Show a hashtag and its associated information
         * @return Tag
         */
        fetch(meta?: HttpMetaParams): Promise<Tag$1>;
        /**
         * Follow a hashtag. Posts containing a followed hashtag will be inserted into your home timeline.
         * @return Tag
         */
        follow(meta?: HttpMetaParams): Promise<Tag$1>;
        /**
         * Unfollow a hashtag. Posts containing a followed hashtag will no longer be inserted into your home timeline.
         * @return Tag
         */
        unfollow(meta?: HttpMetaParams): Promise<Tag$1>;
    };
}

interface ListTimelineParams extends DefaultPaginationParams {
    /** Show only local statuses? Defaults to false. */
    readonly local?: boolean | null;
    /** Show only statuses with media attached? Defaults to false. */
    readonly onlyMedia?: boolean | null;
    /** Remote only */
    readonly remote?: boolean | null;
}
interface ListLinkTimelineParams extends ListTimelineParams {
    /** The URL of the trending article. */
    readonly url: string;
}
interface TimelineRepository {
    home: {
        /**
         * View statuses from followed users.
         * @param params Parameters
         * @return Array of Status
         * @see https://docs.joinmastodon.org/methods/timelines/
         */
        list(params?: ListTimelineParams, meta?: HttpMetaParams): Paginator<Status[], ListTimelineParams>;
    };
    public: {
        /**
         * Public timeline
         * @param params Parameters
         * @return Array of Status
         * @see https://docs.joinmastodon.org/methods/timelines/
         */
        list(params?: ListTimelineParams, meta?: HttpMetaParams): Paginator<Status[], ListTimelineParams>;
    };
    tag: {
        $select(hashtag: string): {
            /**
             * View public statuses containing the given hashtag.
             * @param hashtag Content of a #hashtag, not including # symbol.
             * @param params Parameters
             * @return Array of Status
             * @see https://docs.joinmastodon.org/methods/timelines#tag
             */
            list(params?: ListTimelineParams, meta?: HttpMetaParams): Paginator<Status[], ListTimelineParams>;
        };
    };
    list: {
        $select(id: string): {
            /**
             * View statuses in the given list timeline.
             * @param id Local ID of the list in the database.
             * @param params Query parameter
             * @return Array of Status
             * @see https://docs.joinmastodon.org/methods/timelines/
             */
            list(params?: ListTimelineParams, meta?: HttpMetaParams): Paginator<Status[], ListTimelineParams>;
        };
    };
    direct: {
        /**
         * View statuses with a “direct” privacy, from your account or in your notifications.
         * @returns Array of Status
         * @see https://docs.joinmastodon.org/methods/timelines/
         */
        list(params?: ListTimelineParams, meta?: HttpMetaParams): Paginator<Status[], ListTimelineParams>;
    };
    link: {
        /**
         * View public statuses containing a link to the specified currently-trending article. This only lists statuses from people who have opted in to discoverability features.
         * @returns Array of {@link Status}
         * @see https://docs.joinmastodon.org/methods/timelines/#link
         */
        list(params: ListLinkTimelineParams, meta?: HttpMetaParams): Paginator<Status[], ListLinkTimelineParams>;
    };
}

interface ListTrendsParams {
    /** Maximum number of results to return. Defaults to 10. */
    readonly limit: number;
}
interface TrendRepository {
    statuses: {
        /**
         * View trending statuses
         * @returns Array of Status
         * @see https://docs.joinmastodon.org/methods/trends/#statuses
         */
        list(params?: DefaultPaginationParams, meta?: HttpMetaParams): Paginator<Status[], DefaultPaginationParams>;
    };
    links: {
        /**
         * Links that have been shared more than others.
         * @see https://docs.joinmastodon.org/methods/trends/#links
         */
        list(params?: DefaultPaginationParams, meta?: HttpMetaParams): Paginator<TrendLink[], DefaultPaginationParams>;
    };
    tags: {
        /**
         * Tags that are being used more frequently within the past week.
         * @param params Parameters
         * @return Array of Tag with History
         * @see https://docs.joinmastodon.org/methods/trends/#tags
         */
        list(params?: ListTrendsParams, meta?: HttpMetaParams): Paginator<Tag$1[], ListTrendsParams>;
    };
}

interface ProfileRepository {
    avatar: {
        /**https://github.com/mastodon/mastodon/pull/25124 */
        remove(meta?: HttpMetaParams): Promise<void>;
    };
    header: {
        /**https://github.com/mastodon/mastodon/pull/25124 */
        remove(meta?: HttpMetaParams): Promise<void>;
    };
}

type index$4_AddListAccountsParams = AddListAccountsParams;
type index$4_AdminRepository = AdminRepository;
type index$4_AnnouncementRepository = AnnouncementRepository;
type index$4_AppRepository = AppRepository;
type index$4_BlockRepository = BlockRepository;
type index$4_BookmarkRepository = BookmarkRepository;
type index$4_ConversationRepository = ConversationRepository;
type index$4_CreateAccountNoteParams = CreateAccountNoteParams;
type index$4_CreateAccountParams = CreateAccountParams;
type index$4_CreateAppParams = CreateAppParams;
type index$4_CreateConfirmationParams = CreateConfirmationParams;
type index$4_CreateDomainBlockParams = CreateDomainBlockParams;
type index$4_CreateFeaturedTagParams = CreateFeaturedTagParams;
type index$4_CreateListParams = CreateListParams;
type index$4_CreateMarkersParams = CreateMarkersParams;
type index$4_CreateScheduledStatusParams = CreateScheduledStatusParams;
type index$4_CreateStatusParams = CreateStatusParams;
type index$4_CreateStatusParamsBase = CreateStatusParamsBase;
type index$4_CreateStatusParamsWithMediaIds = CreateStatusParamsWithMediaIds;
type index$4_CreateStatusParamsWithStatus = CreateStatusParamsWithStatus;
type index$4_CreateStatusPollParam = CreateStatusPollParam;
type index$4_CustomEmojiRepository = CustomEmojiRepository;
type index$4_DirectoryOrderType = DirectoryOrderType;
type index$4_DirectoryRepository = DirectoryRepository;
type index$4_DomainBlockRepository = DomainBlockRepository;
type index$4_EmailRepository = EmailRepository;
type index$4_EndorsementRepository = EndorsementRepository;
type index$4_FavouriteRepository = FavouriteRepository;
type index$4_FeaturedTagRepository = FeaturedTagRepository;
type index$4_FetchAccountsParams = FetchAccountsParams;
type index$4_FetchMarkersParams = FetchMarkersParams;
type index$4_FetchRelationshipsParams = FetchRelationshipsParams;
type index$4_FetchStatusesParams = FetchStatusesParams;
type index$4_FollowAccountParams = FollowAccountParams;
type index$4_FollowRequestRepository = FollowRequestRepository;
type index$4_FollowedTagRepository = FollowedTagRepository;
type index$4_ListAccountStatusesParams = ListAccountStatusesParams;
type index$4_ListDirectoryParams = ListDirectoryParams;
type index$4_ListLinkTimelineParams = ListLinkTimelineParams;
type index$4_ListRepository = ListRepository;
type index$4_ListSuggestionParams = ListSuggestionParams;
type index$4_ListTimelineParams = ListTimelineParams;
type index$4_ListTrendsParams = ListTrendsParams;
type index$4_LookupAccountParams = LookupAccountParams;
type index$4_MarkerRepository = MarkerRepository;
type index$4_MuteAccountParams = MuteAccountParams;
type index$4_MuteRepository = MuteRepository;
type index$4_PollRepository = PollRepository;
type index$4_PreferenceRepository = PreferenceRepository;
type index$4_ProfileRepository = ProfileRepository;
type index$4_PushRepository = PushRepository;
type index$4_ReblogStatusParams = ReblogStatusParams;
type index$4_RemoveDomainBlockParams = RemoveDomainBlockParams;
type index$4_RemoveListAccountsParams = RemoveListAccountsParams;
type index$4_ReportAccountParams = ReportAccountParams;
type index$4_ReportRepository = ReportRepository;
type index$4_ScheduledStatusRepository = ScheduledStatusRepository;
type index$4_SearchAccountsParams = SearchAccountsParams;
type index$4_StatusRepository = StatusRepository;
type index$4_TagRepository = TagRepository;
type index$4_TimelineRepository = TimelineRepository;
type index$4_TranslateStatusParams = TranslateStatusParams;
type index$4_TrendRepository = TrendRepository;
type index$4_UpdateCredentialsParams = UpdateCredentialsParams;
type index$4_UpdateListParams = UpdateListParams;
type index$4_UpdateMediaAttachmentParams = UpdateMediaAttachmentParams;
type index$4_UpdateScheduledStatusParams = UpdateScheduledStatusParams;
type index$4_UpdateStatusParams = UpdateStatusParams;
type index$4_VotePollParams = VotePollParams;
declare namespace index$4 {
  export type { AccountRepository$1 as AccountRepository, index$4_AddListAccountsParams as AddListAccountsParams, index$4_AdminRepository as AdminRepository, index$4_AnnouncementRepository as AnnouncementRepository, index$4_AppRepository as AppRepository, index$4_BlockRepository as BlockRepository, index$4_BookmarkRepository as BookmarkRepository, index$4_ConversationRepository as ConversationRepository, index$4_CreateAccountNoteParams as CreateAccountNoteParams, index$4_CreateAccountParams as CreateAccountParams, index$4_CreateAppParams as CreateAppParams, index$4_CreateConfirmationParams as CreateConfirmationParams, index$4_CreateDomainBlockParams as CreateDomainBlockParams, index$4_CreateFeaturedTagParams as CreateFeaturedTagParams, CreateFilterParams$1 as CreateFilterParams, index$4_CreateListParams as CreateListParams, index$4_CreateMarkersParams as CreateMarkersParams, CreateMediaAttachmentParams$1 as CreateMediaAttachmentParams, index$4_CreateScheduledStatusParams as CreateScheduledStatusParams, index$4_CreateStatusParams as CreateStatusParams, index$4_CreateStatusParamsBase as CreateStatusParamsBase, index$4_CreateStatusParamsWithMediaIds as CreateStatusParamsWithMediaIds, index$4_CreateStatusParamsWithStatus as CreateStatusParamsWithStatus, index$4_CreateStatusPollParam as CreateStatusPollParam, index$4_CustomEmojiRepository as CustomEmojiRepository, index$4_DirectoryOrderType as DirectoryOrderType, index$4_DirectoryRepository as DirectoryRepository, index$4_DomainBlockRepository as DomainBlockRepository, index$4_EmailRepository as EmailRepository, index$4_EndorsementRepository as EndorsementRepository, index$4_FavouriteRepository as FavouriteRepository, index$4_FeaturedTagRepository as FeaturedTagRepository, index$4_FetchAccountsParams as FetchAccountsParams, index$4_FetchMarkersParams as FetchMarkersParams, index$4_FetchRelationshipsParams as FetchRelationshipsParams, index$4_FetchStatusesParams as FetchStatusesParams, FetchUnreadCountParams$1 as FetchUnreadCountParams, FilterRepository$1 as FilterRepository, index$4_FollowAccountParams as FollowAccountParams, index$4_FollowRequestRepository as FollowRequestRepository, index$4_FollowedTagRepository as FollowedTagRepository, InstanceRepository$1 as InstanceRepository, index$4_ListAccountStatusesParams as ListAccountStatusesParams, index$4_ListDirectoryParams as ListDirectoryParams, index$4_ListLinkTimelineParams as ListLinkTimelineParams, ListNotificationsParams$1 as ListNotificationsParams, index$4_ListRepository as ListRepository, index$4_ListSuggestionParams as ListSuggestionParams, index$4_ListTimelineParams as ListTimelineParams, index$4_ListTrendsParams as ListTrendsParams, index$4_LookupAccountParams as LookupAccountParams, index$4_MarkerRepository as MarkerRepository, MediaAttachmentRepository$1 as MediaAttachmentRepository, index$4_MuteAccountParams as MuteAccountParams, index$4_MuteRepository as MuteRepository, NotificationRepository$1 as NotificationRepository, index$4_PollRepository as PollRepository, index$4_PreferenceRepository as PreferenceRepository, index$4_ProfileRepository as ProfileRepository, index$4_PushRepository as PushRepository, index$4_ReblogStatusParams as ReblogStatusParams, index$4_RemoveDomainBlockParams as RemoveDomainBlockParams, index$4_RemoveListAccountsParams as RemoveListAccountsParams, index$4_ReportAccountParams as ReportAccountParams, index$4_ReportRepository as ReportRepository, index$4_ScheduledStatusRepository as ScheduledStatusRepository, index$4_SearchAccountsParams as SearchAccountsParams, SearchParams$1 as SearchParams, SearchRepository$1 as SearchRepository, SearchType$1 as SearchType, index$4_StatusRepository as StatusRepository, SuggestionRepository$1 as SuggestionRepository, index$4_TagRepository as TagRepository, index$4_TimelineRepository as TimelineRepository, index$4_TranslateStatusParams as TranslateStatusParams, index$4_TrendRepository as TrendRepository, index$4_UpdateCredentialsParams as UpdateCredentialsParams, UpdateFilterParams$1 as UpdateFilterParams, index$4_UpdateListParams as UpdateListParams, index$4_UpdateMediaAttachmentParams as UpdateMediaAttachmentParams, index$4_UpdateScheduledStatusParams as UpdateScheduledStatusParams, index$4_UpdateStatusParams as UpdateStatusParams, index$4_VotePollParams as VotePollParams };
}

interface CreateFilterParams {
    /** String. The name of the filter group. */
    readonly title: string;
    /** Array of String. Where the filter should be applied. Specify at least one of home, notifications, public, thread, account. */
    readonly context: readonly FilterContext$1[] | null;
    /** String. The policy to be applied when the filter is matched. Specify warn or hide. */
    readonly filterAction?: FilterAction | null;
    /** Integer. How many seconds from now should the filter expire? */
    readonly expiresIn?: number | null;
    readonly keywordsAttributes?: {
        /** String. A keyword to be added to the newly-created filter group. */
        readonly keyword?: string | null;
        /** Boolean. Whether the keyword should consider word boundaries. */
        readonly wholeWord?: boolean | null;
    }[];
}
interface UpdateFilterParams {
    /** String. The name of the filter group. */
    readonly title?: string;
    /** Array of String. Where the filter should be applied. Specify at least one of home, notifications, public, thread, account. */
    readonly context?: readonly FilterContext$1[] | null;
    /** String. The policy to be applied when the filter is matched. Specify warn or hide. */
    readonly filterAction?: FilterAction | null;
    /** Integer. How many seconds from now should the filter expire? */
    readonly expiresIn?: number | null;
    readonly keywordsAttributes?: readonly {
        /** String. Provide the ID of an existing keyword to modify it, instead of creating a new keyword. */
        readonly id?: string | null;
        /** String. A keyword to be added to the newly-created filter group. */
        readonly keyword?: string | null;
        /** Boolean. Whether the keyword should consider word boundaries. */
        readonly wholeWord?: boolean | null;
        /** Boolean. If true, will remove the keyword with the given ID */
        readonly _destroy?: boolean | null;
    }[];
}
interface CreateFilterKeywordParams {
    /** String. The keyword to be added to the filter group. */
    readonly keyword: string;
    /** Boolean. Whether the keyword should consider word boundaries. */
    readonly wholeWord?: boolean | null;
}
type UpdateFilterKeywordParams = CreateFilterKeywordParams;
interface CreateFilterStatusParams {
    readonly statusId: string;
}
interface FilterRepository {
    /**
     * View all filters
     * @return Array of Filter
     * @see https://docs.joinmastodon.org/methods/filters/#get
     */
    list(meta?: HttpMetaParams): Paginator<Filter$1[]>;
    /**
     * Create a filter group with the given parameters.
     * @param params Parameters
     * @return Filter
     * @see https://docs.joinmastodon.org/methods/filters/#create
     */
    create(params?: CreateFilterParams, meta?: HttpMetaParams<"json">): Promise<Filter$1>;
    $select(id: string): {
        /**
         * Obtain a single filter group owned by the current user.
         * @return Filter
         * @see https://docs.joinmastodon.org/methods/filters/#get-one
         */
        fetch(meta?: HttpMetaParams): Promise<Filter$1>;
        /**
         * Update a filter group with the given parameters.
         * @param params Parameters
         * @return Filter
         * @see https://docs.joinmastodon.org/methods/filters/#update
         */
        update(params?: UpdateFilterParams, meta?: HttpMetaParams<"json">): Promise<Filter$1>;
        /**
         * Delete a filter group with the given id.
         * @return N/A
         * @see https://docs.joinmastodon.org/methods/filters/#delete
         */
        remove(meta?: HttpMetaParams): Promise<void>;
        keywords: {
            /**
             * Add the given keyword to the specified filter group
             * @param id String. The ID of the Filter in the database.
             * @param params Parameters
             * @return FilterKeywords
             * @see https://docs.joinmastodon.org/methods/filters/#keywords-create
             */
            create(params: CreateFilterKeywordParams, meta?: HttpMetaParams<"json">): Promise<FilterKeyword>;
            /**
             * List all keywords attached to the current filter group.
             * @returns Array of FilterKeyword
             * @see https://docs.joinmastodon.org/methods/filters/#keywords-get
             */
            list(meta?: HttpMetaParams): Paginator<FilterKeyword[]>;
        };
        statuses: {
            /**
             * Obtain a list of all status filters within this filter group.
             * @returns Array of FilterStatus
             * @see https://docs.joinmastodon.org/methods/filters/#statuses-get
             */
            list(meta?: HttpMetaParams): Paginator<FilterStatus[]>;
            /**
             * Add a status filter to the current filter group.
             * @param params
             * @returns FilterStatus
             * @see https://docs.joinmastodon.org/methods/filters/#statuses-add
             */
            create(params: CreateFilterStatusParams, meta?: HttpMetaParams<"json">): Promise<FilterStatus>;
        };
    };
    keywords: {
        $select(id: string): {
            /**
             * Get one filter keyword by the given id.
             * @returns FilterKeyword
             * @see https://docs.joinmastodon.org/methods/filters/#keywords-get-one
             */
            fetch(meta?: HttpMetaParams): Paginator<FilterKeyword>;
            /**
             * Update the given filter keyword.
             * @param params Parameters
             * @return FilterKeywords
             * @see https://docs.joinmastodon.org/methods/filters/#keywords-update
             */
            update(params: CreateFilterKeywordParams, meta?: HttpMetaParams<"json">): Promise<FilterKeyword>;
            /**
             * Deletes the given filter keyword.
             * @returns empty object
             * @see https://docs.joinmastodon.org/methods/filters/#keywords-delete
             */
            remove(meta?: HttpMetaParams): Promise<void>;
        };
    };
    statuses: {
        $select(id: string): {
            /**
             * Obtain a single status filter.
             * @returns FilterStatus
             * @see https://docs.joinmastodon.org/methods/filters/#statuses-get-one
             */
            fetch(): Promise<FilterStatus>;
            /**
             * @returns FilterStatus
             * @see https://docs.joinmastodon.org/methods/filters/#statuses-get-one
             */
            remove(): Promise<FilterStatus>;
        };
    };
}

interface InstanceRepository {
    /**
     * Information about the server.
     * @return Instance
     * @see https://docs.joinmastodon.org/methods/instance/
     */
    fetch(meta?: HttpMetaParams): Promise<Instance>;
}

interface CreateMediaAttachmentParams {
    /** The file to be attached, using multipart form data. */
    readonly file: Blob | string;
    /** A plain-text description of the media, for accessibility purposes. */
    readonly description?: string | null;
    /** Two floating points (x,y), comma-delimited, ranging from -1.0 to 1.0 */
    readonly focus?: string | null;
    /** Custom thumbnail */
    readonly thumbnail?: Blob | string | null;
}
interface CreateMediaAttachmentExtraParams {
    /** Wait resolving promise for the media to be uploaded. Defaults to `false` */
    readonly skipPolling?: boolean;
}
interface MediaAttachmentRepository {
    /**
     * Creates an attachment to be used with a new status.
     * @param params Parameters
     * @return Attachment
     * @see https://docs.joinmastodon.org/methods/statuses/media/
     */
    create(params: CreateMediaAttachmentParams & CreateMediaAttachmentExtraParams, meta?: HttpMetaParams<"multipart-form">): Promise<MediaAttachment>;
}

interface ListNotificationsParams extends DefaultPaginationParams {
    /** Types to include in the result. */
    readonly types?: readonly NotificationGroupType[] | null;
    /** Types to exclude from the results. */
    readonly excludeTypes?: readonly NotificationGroupType[] | null;
    /** Return only notifications received from the specified account. */
    readonly accountId?: string;
    /**
     * One of full (default) or partial_avatars. When set to partial_avatars,
     * some accounts will not be rendered in full in the returned accounts list but will be
     * instead returned in stripped-down form in the partial_accounts list. The most recent
     * account in a notification group is always rendered in full in the accounts attribute.
     */
    readonly expandAccounts?: "full" | "partial_avatars";
    /**
     * Restrict which notification types can be grouped. Use this if there are notification types
     * for which your client does not support grouping. If omitted, the server will group notifications
     * of all types it supports (currently, favourite, follow and reblog). If you do not want any
     * notification grouping, use GET /api/v1/notifications instead. Notifications that would be
     * grouped if not for this parameter will instead be returned as individual single-notification
     * groups with a unique group_key that can be assumed to be of the form ungrouped-{notification_id}.
     *
     * Please note that neither the streaming API nor the individual notification APIs are aware of this
     * parameter and will always include a “proper” group_key that can be different from what is
     * returned here, meaning that you may have to ignore group_key for such notifications that you do
     * not want grouped and use ungrouped-{notification_id} instead for consistency.
     */
    readonly groupedTypes?: readonly NotificationGroupType[] | null;
    /** Whether to include notifications filtered by the user’s NotificationPolicy. Defaults to false. */
    readonly includeFiltered?: boolean;
}
interface FetchUnreadCountParams {
    /** Maximum number of results to return. Defaults to 100 notifications. Max 1000 notifications. */
    readonly limit?: number;
    /** Types of notifications that should count towards unread notifications. */
    readonly types?: readonly NotificationGroupType[];
    /** Types of notifications that should not count towards unread notifications. */
    readonly excludeTypes?: readonly NotificationGroupType[];
    /** Only count unread notifications received from the specified account. */
    readonly accountId?: string;
    /** Restrict which notification types can be grouped. Use this if there are notification types for which your client does not support grouping. If omitted, the server will group notifications of all types it supports (currently, favourite, follow and reblog). If you do not want any notification grouping, use GET /api/v1/notifications/unread_count instead. */
    readonly groupedTypes?: readonly NotificationGroupType[];
}
interface UpdateNotificationPolicyParams {
    /** Whether to accept, filter or drop notifications from accounts the user is not following. drop will prevent creation of the notification object altogether (without preventing the underlying activity), filter will cause it to be marked as filtered, and accept will not affect its processing. */
    readonly forNotFollowing?: NotificationPolicyType;
    /** Whether to accept, filter or drop notifications from accounts that are not following the user. drop will prevent creation of the notification object altogether (without preventing the underlying activity), filter will cause it to be marked as filtered, and accept will not affect its processing. */
    readonly forNotFollowers?: NotificationPolicyType;
    /** Whether to accept, filter or drop notifications from accounts created in the past 30 days. drop will prevent creation of the notification object altogether (without preventing the underlying activity), filter will cause it to be marked as filtered, and accept will not affect its processing. */
    readonly forNewAccounts?: NotificationPolicyType;
    /** Whether to accept, filter or drop notifications from private mentions. drop will prevent creation of the notification object altogether (without preventing the underlying activity), filter will cause it to be marked as filtered, and accept will not affect its processing. Replies to private mentions initiated by the user, as well as accounts the user follows, are always allowed, regardless of this value. */
    readonly forPrivateMentions?: NotificationPolicyType;
    /** Whether to accept, filter or drop notifications from accounts that were limited by a moderator. drop will prevent creation of the notification object altogether (without preventing the underlying activity), filter will cause it to be marked as filtered, and accept will not affect its processing. */
    readonly forLimitedAccounts?: NotificationPolicyType;
}
interface NotificationRepository {
    /**
     * Return grouped notifications concerning the user. This API returns Link headers containing links
     * to the next/previous page. However, the links can also be constructed dynamically using query
     * params and id values.
     *
     * Notifications of type favourite, follow or reblog with the same type and the same target made in
     * a similar timeframe are given a same group_key by the server, and querying this endpoint will
     * return aggregated notifications, with only one object per group_key. Other notification types may
     * be grouped in the future. The grouped_types parameter should be used by the client to explicitly
     * list the types it supports showing grouped notifications for.
     */
    list(params?: ListNotificationsParams, meta?: HttpMetaParams): Paginator<GroupedNotificationsResults>;
    /**
     * @param groupKey The group key of the notification group.
     */
    $select(groupKey: string): {
        /**
         * View information about a specific notification group with a given group key.
         */
        fetch(meta?: HttpMetaParams): Promise<GroupedNotificationsResults>;
        /**
         * Dismiss a single notification group from the server.
         */
        dismiss(meta?: HttpMetaParams): Promise<void>;
        accounts: {
            fetch(meta?: HttpMetaParams): Promise<Account$1[]>;
        };
    };
    unreadCount: {
        /**
         * Get the (capped) number of unread notification groups for the current user. A notification is
         * considered unread if it is more recent than the notifications read marker. Because the count
         * is dependant on the parameters, it is computed every time and is thus a relatively slow
         * operation (although faster than getting the full corresponding notifications), therefore the
         * number of returned notifications is capped.
         */
        fetch(params?: FetchUnreadCountParams, meta?: HttpMetaParams): Promise<{
            count: number;
        }>;
    };
    policy: {
        /**
         * Notifications filtering policy for the user.
         */
        fetch(meta?: HttpMetaParams): Promise<NotificationPolicy>;
        /**
         * Update the user’s notifications filtering policy.
         */
        update(params: UpdateNotificationPolicyParams, meta?: HttpMetaParams<"json">): Promise<NotificationPolicy>;
    };
}

type SearchType = "accounts" | "hashtags" | "statuses";
interface SearchParams extends DefaultPaginationParams {
    /** Attempt WebFinger lookup. Defaults to false. */
    readonly q: string;
    /** Enum(accounts, hashtags, statuses) */
    readonly type?: SearchType | null;
    /** Attempt WebFinger look-up */
    readonly resolve?: boolean | null;
    /** If provided, statuses returned will be authored only by this account */
    readonly accountId?: string | null;
    /** Filter out unreviewed tags? Defaults to false. Use true when trying to find trending tags. */
    readonly excludeUnreviewed?: boolean | null;
    /** Only include accounts that the user is following. Defaults to false. */
    readonly following?: boolean | null;
    /** Skip the first n results. */
    readonly offset?: number | null;
}
interface SearchRepository {
    /**
     * @deprecated Use `list` instead
     */
    fetch(params: SearchParams, meta?: HttpMetaParams): Search;
    /**
     * Perform a search
     * @param params Parameters
     * @return Results
     * @see https://docs.joinmastodon.org/methods/search/
     */
    list(params: SearchParams, meta?: HttpMetaParams): Paginator<Search, SearchParams>;
}

interface ListSuggestionsParams {
    /** Integer. Maximum number of results to return. Defaults to 40. */
    readonly limit?: number | null;
}
interface SuggestionRepository {
    /**
     * View follow suggestions.
     * Accounts that are promoted by staff, or that the user has had past positive interactions with, but is not yet following.
     * @param params
     * @returns
     */
    list(params?: ListSuggestionsParams, meta?: HttpMetaParams): Paginator<Suggestion[], ListSuggestionsParams>;
}

type index$3_CreateFilterKeywordParams = CreateFilterKeywordParams;
type index$3_CreateFilterParams = CreateFilterParams;
type index$3_CreateFilterStatusParams = CreateFilterStatusParams;
type index$3_CreateMediaAttachmentExtraParams = CreateMediaAttachmentExtraParams;
type index$3_CreateMediaAttachmentParams = CreateMediaAttachmentParams;
type index$3_FetchUnreadCountParams = FetchUnreadCountParams;
type index$3_FilterRepository = FilterRepository;
type index$3_InstanceRepository = InstanceRepository;
type index$3_ListNotificationsParams = ListNotificationsParams;
type index$3_ListSuggestionsParams = ListSuggestionsParams;
type index$3_MediaAttachmentRepository = MediaAttachmentRepository;
type index$3_NotificationRepository = NotificationRepository;
type index$3_SearchParams = SearchParams;
type index$3_SearchRepository = SearchRepository;
type index$3_SearchType = SearchType;
type index$3_SuggestionRepository = SuggestionRepository;
type index$3_UpdateFilterKeywordParams = UpdateFilterKeywordParams;
type index$3_UpdateFilterParams = UpdateFilterParams;
type index$3_UpdateNotificationPolicyParams = UpdateNotificationPolicyParams;
declare namespace index$3 {
  export type { index$3_CreateFilterKeywordParams as CreateFilterKeywordParams, index$3_CreateFilterParams as CreateFilterParams, index$3_CreateFilterStatusParams as CreateFilterStatusParams, index$3_CreateMediaAttachmentExtraParams as CreateMediaAttachmentExtraParams, index$3_CreateMediaAttachmentParams as CreateMediaAttachmentParams, index$3_FetchUnreadCountParams as FetchUnreadCountParams, index$3_FilterRepository as FilterRepository, index$3_InstanceRepository as InstanceRepository, index$3_ListNotificationsParams as ListNotificationsParams, index$3_ListSuggestionsParams as ListSuggestionsParams, index$3_MediaAttachmentRepository as MediaAttachmentRepository, index$3_NotificationRepository as NotificationRepository, index$3_SearchParams as SearchParams, index$3_SearchRepository as SearchRepository, index$3_SearchType as SearchType, index$3_SuggestionRepository as SuggestionRepository, index$3_UpdateFilterKeywordParams as UpdateFilterKeywordParams, index$3_UpdateFilterParams as UpdateFilterParams, index$3_UpdateNotificationPolicyParams as UpdateNotificationPolicyParams };
}

interface Client$2 {
    readonly v1: {
        readonly admin: AdminRepository;
        readonly accounts: AccountRepository$1;
        readonly announcements: AnnouncementRepository;
        readonly apps: AppRepository;
        readonly blocks: BlockRepository;
        readonly bookmarks: BookmarkRepository;
        readonly conversations: ConversationRepository;
        readonly customEmojis: CustomEmojiRepository;
        readonly directory: DirectoryRepository;
        readonly domainBlocks: DomainBlockRepository;
        readonly endorsements: EndorsementRepository;
        readonly favourites: FavouriteRepository;
        readonly featuredTags: FeaturedTagRepository;
        readonly filters: FilterRepository$1;
        readonly followRequests: FollowRequestRepository;
        readonly instance: InstanceRepository$1;
        readonly lists: ListRepository;
        readonly markers: MarkerRepository;
        readonly media: MediaAttachmentRepository$1;
        readonly mutes: MuteRepository;
        readonly notifications: NotificationRepository$1;
        readonly polls: PollRepository;
        readonly preferences: PreferenceRepository;
        readonly reports: ReportRepository;
        readonly scheduledStatuses: ScheduledStatusRepository;
        readonly search: SearchRepository$1;
        readonly statuses: StatusRepository;
        readonly suggestions: SuggestionRepository$1;
        readonly timelines: TimelineRepository;
        readonly trends: TrendRepository;
        readonly emails: EmailRepository;
        readonly tags: TagRepository;
        readonly followedTags: FollowedTagRepository;
        readonly push: PushRepository;
        readonly profile: ProfileRepository;
    };
    readonly v2: {
        readonly filters: FilterRepository;
        readonly instance: InstanceRepository;
        readonly media: MediaAttachmentRepository;
        readonly notifications: NotificationRepository;
        readonly suggestions: SuggestionRepository;
        readonly search: SearchRepository;
    };
}

declare namespace index$2 {
  export { type Client$2 as Client, index$4 as v1, index$3 as v2 };
}

interface RawEventOk {
    stream: string[];
    event: string;
    payload?: string;
}
interface RawEventError {
    error: string;
}
type RawEvent = RawEventOk | RawEventError;
interface BaseEvent<T, U> {
    stream: string[];
    event: T;
    payload: U;
}
type UpdateEvent = BaseEvent<"update", Status>;
type DeleteEvent = BaseEvent<"delete", string>;
type NotificationEvent = BaseEvent<"notification", Notification>;
type FiltersChangedEvent = BaseEvent<"filters_changed", undefined>;
type ConversationEvent = BaseEvent<"conversation", Conversation>;
type AnnouncementEvent = BaseEvent<"announcement", Announcement>;
type AnnouncementReactionEvent = BaseEvent<"announcement.reaction", Reaction>;
type AnnouncementDeleteEvent = BaseEvent<"announcement.delete", string>;
type StatusUpdateEvent = BaseEvent<"status.update", Status>;
/** Accepted notification requests have finished merging, and the notifications list should be refreshed. Payload can be ignored. Available since v4.3.0 */
type NotificationsMergedEvent = BaseEvent<"notifications_merged", undefined>;
type Event = UpdateEvent | DeleteEvent | NotificationEvent | FiltersChangedEvent | ConversationEvent | AnnouncementEvent | AnnouncementReactionEvent | AnnouncementDeleteEvent | StatusUpdateEvent | NotificationsMergedEvent;

interface SubscribeListParams {
    readonly list: string;
}
interface SubscribeHashtagParams {
    readonly tag: string;
}
interface Subscription extends AsyncIterable<Event>, Disposable {
    values(): AsyncIterableIterator<Event>;
    unsubscribe(): void;
}
interface Client$1 extends Disposable {
    public: {
        subscribe(): Subscription;
        media: {
            subscribe(): Subscription;
        };
        local: {
            subscribe(): Subscription;
            media: {
                subscribe(): Subscription;
            };
        };
        remote: {
            subscribe(): Subscription;
            media: {
                subscribe(): Subscription;
            };
        };
    };
    hashtag: {
        subscribe(params: SubscribeHashtagParams): Subscription;
        local: {
            subscribe(params: SubscribeHashtagParams): Subscription;
        };
    };
    list: {
        subscribe(params: SubscribeListParams): Subscription;
    };
    direct: {
        subscribe(): Subscription;
    };
    user: {
        subscribe(): Subscription;
        notification: {
            subscribe(): Subscription;
        };
    };
    close(): void;
    /** @internal */
    prepare(): Promise<void>;
}

type index$1_AnnouncementDeleteEvent = AnnouncementDeleteEvent;
type index$1_AnnouncementEvent = AnnouncementEvent;
type index$1_AnnouncementReactionEvent = AnnouncementReactionEvent;
type index$1_ConversationEvent = ConversationEvent;
type index$1_DeleteEvent = DeleteEvent;
type index$1_Event = Event;
type index$1_FiltersChangedEvent = FiltersChangedEvent;
type index$1_NotificationEvent = NotificationEvent;
type index$1_NotificationsMergedEvent = NotificationsMergedEvent;
type index$1_RawEvent = RawEvent;
type index$1_RawEventError = RawEventError;
type index$1_RawEventOk = RawEventOk;
type index$1_StatusUpdateEvent = StatusUpdateEvent;
type index$1_SubscribeHashtagParams = SubscribeHashtagParams;
type index$1_SubscribeListParams = SubscribeListParams;
type index$1_Subscription = Subscription;
type index$1_UpdateEvent = UpdateEvent;
declare namespace index$1 {
  export type { index$1_AnnouncementDeleteEvent as AnnouncementDeleteEvent, index$1_AnnouncementEvent as AnnouncementEvent, index$1_AnnouncementReactionEvent as AnnouncementReactionEvent, Client$1 as Client, index$1_ConversationEvent as ConversationEvent, index$1_DeleteEvent as DeleteEvent, index$1_Event as Event, index$1_FiltersChangedEvent as FiltersChangedEvent, index$1_NotificationEvent as NotificationEvent, index$1_NotificationsMergedEvent as NotificationsMergedEvent, index$1_RawEvent as RawEvent, index$1_RawEventError as RawEventError, index$1_RawEventOk as RawEventOk, index$1_StatusUpdateEvent as StatusUpdateEvent, index$1_SubscribeHashtagParams as SubscribeHashtagParams, index$1_SubscribeListParams as SubscribeListParams, index$1_Subscription as Subscription, index$1_UpdateEvent as UpdateEvent };
}

/**
 * @deprecated Use `CreateTokenParamsWithPassword` instead
 */
type CreateTokenParamsWithPassword = CreateTokenWithPasswordParams;
interface BaseCreateTokenParams<T extends string> {
    /** Set equal to `authorization_code` if code is provided in order to gain user-level access. Otherwise, set equal to `client_credentials` to obtain app-level access only. */
    readonly grantType: T;
    /** The client ID, obtained during app registration. */
    readonly clientId: string;
    /** The client secret, obtained during app registration. */
    readonly clientSecret: string;
    /** Set a URI to redirect the user to. If this parameter is set to urn:ietf:wg:oauth:2.0:oob then the token will be shown instead. Must match one of the `redirect_uris` declared during app registration. */
    readonly redirectUri: string;
    /** List of requested OAuth scopes, separated by spaces (or by pluses, if using query parameters). If code was provided, then this must be equal to the `scope` requested from the user. Otherwise, it must be a subset of `scopes` declared during app registration. If not provided, defaults to read. */
    readonly scope?: string | null;
}
interface CreateTokenWithAuthorizationCodeParams extends BaseCreateTokenParams<"authorization_code"> {
    /** A user authorization code, obtained via GET /oauth/authorize. */
    readonly code: string;
}
type CreateTokenWithClientCredentialsParams = BaseCreateTokenParams<"client_credentials">;
interface CreateTokenWithPasswordParams extends BaseCreateTokenParams<"password"> {
    readonly password: string;
    readonly username: string;
}
type CreateTokenParams = CreateTokenWithClientCredentialsParams | CreateTokenWithPasswordParams | CreateTokenWithAuthorizationCodeParams;
interface TokenRepository {
    create(params: CreateTokenParams, meta?: HttpMetaParams<"multipart-form">): Promise<Token>;
}

interface RevokeTokenParams {
    /** The client ID, obtained during app registration. */
    readonly clientId: string;
    /** The client secret, obtained during app registration. */
    readonly clientSecret: string;
    /** The previously obtained token, to be invalidated. */
    readonly token: string;
}
interface Client {
    readonly token: TokenRepository;
    /**
     * Revoke an access token to make it no longer valid for use.
     * @param params Form data parameters
     * @param meta HTTP metadata
     * @see https://docs.joinmastodon.org/methods/oauth/#revoke
     */
    revoke(params: RevokeTokenParams, meta?: HttpMetaParams<"multipart-form">): Promise<void>;
}

type index_Client = Client;
type index_CreateTokenParams = CreateTokenParams;
type index_CreateTokenParamsWithPassword = CreateTokenParamsWithPassword;
type index_CreateTokenWithAuthorizationCodeParams = CreateTokenWithAuthorizationCodeParams;
type index_CreateTokenWithClientCredentialsParams = CreateTokenWithClientCredentialsParams;
type index_CreateTokenWithPasswordParams = CreateTokenWithPasswordParams;
type index_RevokeTokenParams = RevokeTokenParams;
type index_TokenRepository = TokenRepository;
declare namespace index {
  export type { index_Client as Client, index_CreateTokenParams as CreateTokenParams, index_CreateTokenParamsWithPassword as CreateTokenParamsWithPassword, index_CreateTokenWithAuthorizationCodeParams as CreateTokenWithAuthorizationCodeParams, index_CreateTokenWithClientCredentialsParams as CreateTokenWithClientCredentialsParams, index_CreateTokenWithPasswordParams as CreateTokenWithPasswordParams, index_RevokeTokenParams as RevokeTokenParams, index_TokenRepository as TokenRepository };
}

type mastodon_DefaultPaginationParams = DefaultPaginationParams;
type mastodon_Direction = Direction;
type mastodon_Paginator<Entity, Params = undefined> = Paginator<Entity, Params>;
declare namespace mastodon {
  export { type mastodon_DefaultPaginationParams as DefaultPaginationParams, type mastodon_Direction as Direction, type mastodon_Paginator as Paginator, index as oauth, index$2 as rest, index$1 as streaming, index$6 as v1, index$5 as v2 };
}

interface MastoHttpConfigProps {
    /**
     * REST API URL for your Mastodon instance.
     */
    readonly url: string;
    /**
     * Access token for the REST API.
     *
     * Please refer to the [quickstart](https://github.com/neet/masto.js?tab=readme-ov-file#quick-start) for how to get an access token.
     */
    readonly accessToken?: string;
    /**
     * Timeout milliseconds for the fetch request.
     *
     * Defaults to browser's default timeout.
     */
    readonly timeout?: number;
    /**
     * Additional options for the `fetch` function.
     *
     * @see https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch
     */
    readonly requestInit?: Omit<RequestInit, "body" | "method">;
}

interface WebSocketConfigProps {
    /**
     * Streaming API URL for your Mastodon instance.
     *
     * Note that this is often different from the REST API URL.
     *
     * If you are not sure which URL to use, you can obtain it via the following script:
     *
     * @example
     * ```ts
     * import { createRestAPIClient, createStreamingAPIClient } from "masto";
     *
     * const rest = createRestAPIClient({
     *   url: "https://example.com",
     * });
     *
     * const instance = await rest.v2.instance.fetch();
     *
     * const streaming = createStreamingAPIClient({
     *  streamingApiUrl: instance.configuration.urls.streaming,
     * })
     * ```
     */
    readonly streamingApiUrl: string;
    /**
     * Access token for the streaming API.
     *
     * If it is not provided, you won't be able to use private APIs.
     */
    readonly accessToken?: string;
    /**
     * Whether to retry the connection when it fails.
     *
     * - If `true`, it will retry indefinitely.
     * - If `false`, it will not retry.
     * - If a number, it will retry that many times.
     *
     * Defaults to `true`.
     */
    readonly retry?: boolean | number;
    /**
     * Whether to use the access token as a query parameter.
     *
     * This is useful when your instance runs an old version of Mastodon that does not support the `Sec-Websocket-Protocols`
     *
     * Defaults to `false`.
     */
    readonly useInsecureAccessToken?: boolean;
}

interface LogConfigProps {
    /**
     * Log level for the client.
     *
     * - `debug`: Log everything.
     * - `info`: Log important information.
     * - `warn`: Log warnings.
     * - `error`: Log errors.
     *
     * Defaults to `warn`.
     */
    readonly log?: LogType;
}
declare const createRestAPIClient: (props: MastoHttpConfigProps & LogConfigProps) => Client$2;
declare const createOAuthAPIClient: (props: MastoHttpConfigProps & LogConfigProps) => Client;
interface WebSocketCustomImplProps {
    /**
     * Custom WebSocket implementation. In Deno, you can use `WebSocket` to avoid potential errors.
     *
     * Defaults to `window.WebSocket`.
     */
    readonly implementation?: unknown;
}
declare function createStreamingAPIClient(props: WebSocketConfigProps & LogConfigProps & WebSocketCustomImplProps): Client$1;

export { MastoDeserializeError, type MastoErrorType, MastoHttpError, type MastoHttpErrorDetail, type MastoHttpErrorDetails, type MastoHttpErrorProps, MastoInvalidArgumentError, MastoTimeoutError, MastoUnexpectedError, MastoWebSocketError, createOAuthAPIClient, createRestAPIClient, createStreamingAPIClient, mastodon };
